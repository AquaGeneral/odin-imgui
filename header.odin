package imgui;

color_hsv     :: inline proc(pOut: ^Color, self: ^Color, h: f32, s: f32, v: f32, a := f32(1.0)) do ImColor_HSV(pOut, self, h, s, v, a);
color_set_hsv :: inline proc(self: ^Color, h: f32, s: f32, v: f32, a := f32(1.0))        do ImColor_SetHSV(self, h, s, v, a);

draw_data_builder_clear                     :: inline proc(self: ^Draw_Data_Builder) do ImDrawDataBuilder_Clear(self);
draw_data_builder_clear_free_memory         :: inline proc(self: ^Draw_Data_Builder) do ImDrawDataBuilder_ClearFreeMemory(self);
draw_data_builder_flatten_into_single_layer :: inline proc(self: ^Draw_Data_Builder) do ImDrawDataBuilder_FlattenIntoSingleLayer(self);

draw_data_clear                :: inline proc(self: ^Draw_Data)                 do ImDrawData_Clear(self);
draw_data_de_index_all_buffers :: inline proc(self: ^Draw_Data)                 do ImDrawData_DeIndexAllBuffers(self);
draw_data_scale_clip_rects     :: inline proc(self: ^Draw_Data, fb_scale: Vec2) do ImDrawData_ScaleClipRects(self, fb_scale);

draw_list_shared_data_set_circle_segment_max_error :: inline proc(self: ^Draw_List_Shared_Data, max_error: f32) do ImDrawListSharedData_SetCircleSegmentMaxError(self, max_error);

draw_list_splitter_clear               :: inline proc(self: ^Draw_List_Splitter)                                          do ImDrawListSplitter_Clear(self);
draw_list_splitter_clear_free_memory   :: inline proc(self: ^Draw_List_Splitter)                                          do ImDrawListSplitter_ClearFreeMemory(self);
draw_list_splitter_merge               :: inline proc(self: ^Draw_List_Splitter, draw_list: ^Draw_List)                   do ImDrawListSplitter_Merge(self, draw_list);
draw_list_splitter_set_current_channel :: inline proc(self: ^Draw_List_Splitter, draw_list: ^Draw_List, channel_idx: i32) do ImDrawListSplitter_SetCurrentChannel(self, draw_list, channel_idx);
draw_list_splitter_split               :: inline proc(self: ^Draw_List_Splitter, draw_list: ^Draw_List, count: i32)       do ImDrawListSplitter_Split(self, draw_list, count);

draw_list_add_bezier_curve             :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, col: u32, thickness: f32, num_segments := i32(0))                                                        do ImDrawList_AddBezierCurve(self, p1, p2, p3, p4, col, thickness, num_segments);
draw_list_add_callback                 :: inline proc(self: ^Draw_List, callback: Draw_Callback, callback_data: rawptr)                                                                                                  do ImDrawList_AddCallback(self, callback, callback_data);
draw_list_add_circle                   :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, col: u32, num_segments := i32(12), thickness := f32(1.0))                                                             do ImDrawList_AddCircle(self, center, radius, col, num_segments, thickness);
draw_list_add_circle_filled            :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, col: u32, num_segments := i32(12))                                                                                    do ImDrawList_AddCircleFilled(self, center, radius, col, num_segments);
draw_list_add_convex_poly_filled       :: inline proc(self: ^Draw_List, points: ^Vec2, num_points: i32, col: u32)                                                                                                        do ImDrawList_AddConvexPolyFilled(self, points, num_points, col);
draw_list_add_draw_cmd                 :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_AddDrawCmd(self);
draw_list_add_image                    :: inline proc(self: ^Draw_List, user_texture_id: Texture_ID, p_min: Vec2, p_max: Vec2, uv_min := Vec2(Vec2{0,0}), uv_max := Vec2(Vec2{1,1}), col: u32)                           do ImDrawList_AddImage(self, user_texture_id, p_min, p_max, uv_min, uv_max, col);
draw_list_add_image_quad               :: inline proc(self: ^Draw_List, user_texture_id: Texture_ID, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, uv1 := Vec2(Vec2{0,0}), uv2 := Vec2(Vec2{1,0}), uv3 := Vec2(Vec2{1,1}), uv4 := Vec2(Vec2{0,1}), col: u32) do ImDrawList_AddImageQuad(self, user_texture_id, p1, p2, p3, p4, uv1, uv2, uv3, uv4, col);
draw_list_add_image_rounded            :: inline proc(self: ^Draw_List, user_texture_id: Texture_ID, p_min: Vec2, p_max: Vec2, uv_min: Vec2, uv_max: Vec2, col: u32, rounding: f32, rounding_corners := Draw_Corner_Flags(Draw_Corner_Flags.All)) do ImDrawList_AddImageRounded(self, user_texture_id, p_min, p_max, uv_min, uv_max, col, rounding, rounding_corners);
draw_list_add_line                     :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, col: u32, thickness := f32(1.0))                                                                                             do ImDrawList_AddLine(self, p1, p2, col, thickness);
draw_list_add_ngon                     :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, col: u32, num_segments: i32, thickness := f32(1.0))                                                                   do ImDrawList_AddNgon(self, center, radius, col, num_segments, thickness);
draw_list_add_ngon_filled              :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, col: u32, num_segments: i32)                                                                                          do ImDrawList_AddNgonFilled(self, center, radius, col, num_segments);
draw_list_add_polyline                 :: inline proc(self: ^Draw_List, points: ^Vec2, num_points: i32, col: u32, closed: bool, thickness: f32)                                                                          do ImDrawList_AddPolyline(self, points, num_points, col, closed, thickness);
draw_list_add_quad                     :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, col: u32, thickness := f32(1.0))                                                                         do ImDrawList_AddQuad(self, p1, p2, p3, p4, col, thickness);
draw_list_add_quad_filled              :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, col: u32)                                                                                                do ImDrawList_AddQuadFilled(self, p1, p2, p3, p4, col);
draw_list_add_rect                     :: inline proc(self: ^Draw_List, p_min: Vec2, p_max: Vec2, col: u32, rounding := f32(0.0), rounding_corners := Draw_Corner_Flags(Draw_Corner_Flags.All), thickness := f32(1.0))   do ImDrawList_AddRect(self, p_min, p_max, col, rounding, rounding_corners, thickness);
draw_list_add_rect_filled              :: inline proc(self: ^Draw_List, p_min: Vec2, p_max: Vec2, col: u32, rounding := f32(0.0), rounding_corners := Draw_Corner_Flags(Draw_Corner_Flags.All))                          do ImDrawList_AddRectFilled(self, p_min, p_max, col, rounding, rounding_corners);
draw_list_add_rect_filled_multi_color  :: inline proc(self: ^Draw_List, p_min: Vec2, p_max: Vec2, col_upr_left: u32, col_upr_right: u32, col_bot_right: u32, col_bot_left: u32)                                          do ImDrawList_AddRectFilledMultiColor(self, p_min, p_max, col_upr_left, col_upr_right, col_bot_right, col_bot_left);

add_text :: proc {
	draw_list_add_text_vec2,
	draw_list_add_text_font_ptr,
};
draw_list_add_text_vec2                :: inline proc(self: ^Draw_List, pos: Vec2, col: u32, text_begin: string, text_end := "")                                                                                         do swr_ImDrawList_AddTextVec2(self, pos, col, text_begin, text_end);
draw_list_add_text_font_ptr            :: inline proc(self: ^Draw_List, font: ^ImFont, font_size: f32, pos: Vec2, col: u32, text_begin: string, text_end := "", wrap_width := f32(0.0), cpu_fine_clip_rect : ^Vec4 = nil) do swr_ImDrawList_AddTextFontPtr(self, font, font_size, pos, col, text_begin, text_end, wrap_width, cpu_fine_clip_rect);

draw_list_add_triangle                 :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, p3: Vec2, col: u32, thickness := f32(1.0))                                                                                   do ImDrawList_AddTriangle(self, p1, p2, p3, col, thickness);
draw_list_add_triangle_filled          :: inline proc(self: ^Draw_List, p1: Vec2, p2: Vec2, p3: Vec2, col: u32)                                                                                                          do ImDrawList_AddTriangleFilled(self, p1, p2, p3, col);
draw_list_channels_merge               :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_ChannelsMerge(self);
draw_list_channels_set_current         :: inline proc(self: ^Draw_List, n: i32)                                                                                                                                          do ImDrawList_ChannelsSetCurrent(self, n);
draw_list_channels_split               :: inline proc(self: ^Draw_List, count: i32)                                                                                                                                      do ImDrawList_ChannelsSplit(self, count);
draw_list_clear                        :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_Clear(self);
draw_list_clear_free_memory            :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_ClearFreeMemory(self);
draw_list_clone_output                 :: inline proc(self: ^Draw_List) -> ^Draw_List                                                                                                                                    do return ImDrawList_CloneOutput(self);
draw_list_get_clip_rect_max            :: inline proc(pOut: ^Vec2, self: ^Draw_List)                                                                                                                                     do ImDrawList_GetClipRectMax(pOut, self);
draw_list_get_clip_rect_min            :: inline proc(pOut: ^Vec2, self: ^Draw_List)                                                                                                                                     do ImDrawList_GetClipRectMin(pOut, self);
draw_list_path_arc_to                  :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, a_min: f32, a_max: f32, num_segments := i32(10))                                                                      do ImDrawList_PathArcTo(self, center, radius, a_min, a_max, num_segments);
draw_list_path_arc_to_fast             :: inline proc(self: ^Draw_List, center: Vec2, radius: f32, a_min_of_12: i32, a_max_of_12: i32)                                                                                   do ImDrawList_PathArcToFast(self, center, radius, a_min_of_12, a_max_of_12);
draw_list_path_bezier_curve_to         :: inline proc(self: ^Draw_List, p2: Vec2, p3: Vec2, p4: Vec2, num_segments := i32(0))                                                                                            do ImDrawList_PathBezierCurveTo(self, p2, p3, p4, num_segments);
draw_list_path_clear                   :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_PathClear(self);
draw_list_path_fill_convex             :: inline proc(self: ^Draw_List, col: u32)                                                                                                                                        do ImDrawList_PathFillConvex(self, col);
draw_list_path_line_to                 :: inline proc(self: ^Draw_List, pos: Vec2)                                                                                                                                       do ImDrawList_PathLineTo(self, pos);
draw_list_path_line_to_merge_duplicate :: inline proc(self: ^Draw_List, pos: Vec2)                                                                                                                                       do ImDrawList_PathLineToMergeDuplicate(self, pos);
draw_list_path_rect                    :: inline proc(self: ^Draw_List, rect_min: Vec2, rect_max: Vec2, rounding := f32(0.0), rounding_corners := Draw_Corner_Flags(Draw_Corner_Flags.All))                              do ImDrawList_PathRect(self, rect_min, rect_max, rounding, rounding_corners);
draw_list_path_stroke                  :: inline proc(self: ^Draw_List, col: u32, closed: bool, thickness := f32(1.0))                                                                                                   do ImDrawList_PathStroke(self, col, closed, thickness);
draw_list_pop_clip_rect                :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_PopClipRect(self);
draw_list_pop_texture_id               :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_PopTextureID(self);
draw_list_prim_quad_uv                 :: inline proc(self: ^Draw_List, a: Vec2, b: Vec2, c: Vec2, d: Vec2, uv_a: Vec2, uv_b: Vec2, uv_c: Vec2, uv_d: Vec2, col: u32)                                                    do ImDrawList_PrimQuadUV(self, a, b, c, d, uv_a, uv_b, uv_c, uv_d, col);
draw_list_prim_rect                    :: inline proc(self: ^Draw_List, a: Vec2, b: Vec2, col: u32)                                                                                                                      do ImDrawList_PrimRect(self, a, b, col);
draw_list_prim_rect_uv                 :: inline proc(self: ^Draw_List, a: Vec2, b: Vec2, uv_a: Vec2, uv_b: Vec2, col: u32)                                                                                              do ImDrawList_PrimRectUV(self, a, b, uv_a, uv_b, col);
draw_list_prim_reserve                 :: inline proc(self: ^Draw_List, idx_count: i32, vtx_count: i32)                                                                                                                  do ImDrawList_PrimReserve(self, idx_count, vtx_count);
draw_list_prim_unreserve               :: inline proc(self: ^Draw_List, idx_count: i32, vtx_count: i32)                                                                                                                  do ImDrawList_PrimUnreserve(self, idx_count, vtx_count);
draw_list_prim_vtx                     :: inline proc(self: ^Draw_List, pos: Vec2, uv: Vec2, col: u32)                                                                                                                   do ImDrawList_PrimVtx(self, pos, uv, col);
draw_list_prim_write_idx               :: inline proc(self: ^Draw_List, idx: Draw_Idx)                                                                                                                                   do ImDrawList_PrimWriteIdx(self, idx);
draw_list_prim_write_vtx               :: inline proc(self: ^Draw_List, pos: Vec2, uv: Vec2, col: u32)                                                                                                                   do ImDrawList_PrimWriteVtx(self, pos, uv, col);
draw_list_push_clip_rect               :: inline proc(self: ^Draw_List, clip_rect_min: Vec2, clip_rect_max: Vec2, intersect_with_current_clip_rect := bool(false))                                                       do ImDrawList_PushClipRect(self, clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
draw_list_push_clip_rect_full_screen   :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_PushClipRectFullScreen(self);
draw_list_push_texture_id              :: inline proc(self: ^Draw_List, texture_id: Texture_ID)                                                                                                                          do ImDrawList_PushTextureID(self, texture_id);
draw_list_update_clip_rect             :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_UpdateClipRect(self);
draw_list_update_texture_id            :: inline proc(self: ^Draw_List)                                                                                                                                                  do ImDrawList_UpdateTextureID(self);

font_atlas_custom_rect_is_packed :: inline proc(self: ^Font_Atlas_Custom_Rect) -> bool do return ImFontAtlasCustomRect_IsPacked(self);

font_atlas_add_custom_rect_font_glyph                 :: inline proc(self: ^Font_Atlas, font: ^ImFont, id: Wchar, width: i32, height: i32, advance_x: f32, offset := Vec2(Vec2{0,0})) -> i32                                do return ImFontAtlas_AddCustomRectFontGlyph(self, font, id, width, height, advance_x, offset);
font_atlas_add_custom_rect_regular                    :: inline proc(self: ^Font_Atlas, id: u32, width: i32, height: i32) -> i32                                                                                            do return ImFontAtlas_AddCustomRectRegular(self, id, width, height);
font_atlas_add_font                                   :: inline proc(self: ^Font_Atlas, font_cfg: ^Font_Config) -> ^ImFont                                                                                                  do return ImFontAtlas_AddFont(self, font_cfg);
font_atlas_add_font_default                           :: inline proc(self: ^Font_Atlas, font_cfg : ^Font_Config = nil) -> ^ImFont                                                                                           do return ImFontAtlas_AddFontDefault(self, font_cfg);
font_atlas_add_font_from_file_ttf                     :: inline proc(self: ^Font_Atlas, filename: string, size_pixels: f32, font_cfg : ^Font_Config = nil, glyph_ranges : ^Wchar = nil) -> ^ImFont                          do return swr_ImFontAtlas_AddFontFromFileTTF(self, filename, size_pixels, font_cfg, glyph_ranges);
font_atlas_add_font_from_memory_compressed_base85ttf  :: inline proc(self: ^Font_Atlas, compressed_font_data_base85: string, size_pixels: f32, font_cfg : ^Font_Config = nil, glyph_ranges : ^Wchar = nil) -> ^ImFont       do return swr_ImFontAtlas_AddFontFromMemoryCompressedBase85TTF(self, compressed_font_data_base85, size_pixels, font_cfg, glyph_ranges);
font_atlas_add_font_from_memory_compressed_ttf        :: inline proc(self: ^Font_Atlas, compressed_font_data: rawptr, compressed_font_size: i32, size_pixels: f32, font_cfg : ^Font_Config = nil, glyph_ranges : ^Wchar = nil) -> ^ImFont do return ImFontAtlas_AddFontFromMemoryCompressedTTF(self, compressed_font_data, compressed_font_size, size_pixels, font_cfg, glyph_ranges);
font_atlas_add_font_from_memory_ttf                   :: inline proc(self: ^Font_Atlas, font_data: rawptr, font_size: i32, size_pixels: f32, font_cfg : ^Font_Config = nil, glyph_ranges : ^Wchar = nil) -> ^ImFont         do return ImFontAtlas_AddFontFromMemoryTTF(self, font_data, font_size, size_pixels, font_cfg, glyph_ranges);
font_atlas_build                                      :: inline proc(self: ^Font_Atlas) -> bool                                                                                                                             do return ImFontAtlas_Build(self);
font_atlas_calc_custom_rect_uv                        :: inline proc(self: ^Font_Atlas, rect: ^Font_Atlas_Custom_Rect, out_uv_min: ^Vec2, out_uv_max: ^Vec2)                                                                do ImFontAtlas_CalcCustomRectUV(self, rect, out_uv_min, out_uv_max);
font_atlas_clear                                      :: inline proc(self: ^Font_Atlas)                                                                                                                                     do ImFontAtlas_Clear(self);
font_atlas_clear_fonts                                :: inline proc(self: ^Font_Atlas)                                                                                                                                     do ImFontAtlas_ClearFonts(self);
font_atlas_clear_input_data                           :: inline proc(self: ^Font_Atlas)                                                                                                                                     do ImFontAtlas_ClearInputData(self);
font_atlas_clear_tex_data                             :: inline proc(self: ^Font_Atlas)                                                                                                                                     do ImFontAtlas_ClearTexData(self);
font_atlas_get_custom_rect_by_index                   :: inline proc(self: ^Font_Atlas, index: i32) -> ^Font_Atlas_Custom_Rect                                                                                              do return ImFontAtlas_GetCustomRectByIndex(self, index);
font_atlas_get_glyph_ranges_chinese_full              :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesChineseFull(self);
font_atlas_get_glyph_ranges_chinese_simplified_common :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesChineseSimplifiedCommon(self);
font_atlas_get_glyph_ranges_cyrillic                  :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesCyrillic(self);
font_atlas_get_glyph_ranges_default                   :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesDefault(self);
font_atlas_get_glyph_ranges_japanese                  :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesJapanese(self);
font_atlas_get_glyph_ranges_korean                    :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesKorean(self);
font_atlas_get_glyph_ranges_thai                      :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesThai(self);
font_atlas_get_glyph_ranges_vietnamese                :: inline proc(self: ^Font_Atlas) -> ^Wchar                                                                                                                           do return ImFontAtlas_GetGlyphRangesVietnamese(self);
font_atlas_get_mouse_cursor_tex_data                  :: inline proc(self: ^Font_Atlas, cursor: Mouse_Cursor, out_offset: ^Vec2, out_size: ^Vec2, out_uv_border: [2]Vec2, out_uv_fill: [2]Vec2) -> bool                     do return ImFontAtlas_GetMouseCursorTexData(self, cursor, out_offset, out_size, out_uv_border, out_uv_fill);
font_atlas_get_tex_data_as_alpha8                     :: inline proc(self: ^Font_Atlas, out_pixels: ^^u8, out_width: ^i32, out_height: ^i32, out_bytes_per_pixel : ^i32 = nil)                                              do ImFontAtlas_GetTexDataAsAlpha8(self, out_pixels, out_width, out_height, out_bytes_per_pixel);
font_atlas_get_tex_data_as_rgba32                     :: inline proc(self: ^Font_Atlas, out_pixels: ^^u8, out_width: ^i32, out_height: ^i32, out_bytes_per_pixel : ^i32 = nil)                                              do ImFontAtlas_GetTexDataAsRGBA32(self, out_pixels, out_width, out_height, out_bytes_per_pixel);
font_atlas_is_built                                   :: inline proc(self: ^Font_Atlas) -> bool                                                                                                                             do return ImFontAtlas_IsBuilt(self);
font_atlas_set_tex_id                                 :: inline proc(self: ^Font_Atlas, id: Texture_ID)                                                                                                                     do ImFontAtlas_SetTexID(self, id);

font_glyph_ranges_builder_add_char     :: inline proc(self: ^Font_Glyph_Ranges_Builder, c: Wchar)                         do ImFontGlyphRangesBuilder_AddChar(self, c);
font_glyph_ranges_builder_add_ranges   :: inline proc(self: ^Font_Glyph_Ranges_Builder, ranges: ^Wchar)                   do ImFontGlyphRangesBuilder_AddRanges(self, ranges);
font_glyph_ranges_builder_add_text     :: inline proc(self: ^Font_Glyph_Ranges_Builder, text: string, text_end := "")     do swr_ImFontGlyphRangesBuilder_AddText(self, text, text_end);
font_glyph_ranges_builder_build_ranges :: inline proc(self: ^Font_Glyph_Ranges_Builder, out_ranges: ^Im_Vector(Wchar))    do ImFontGlyphRangesBuilder_BuildRanges(self, out_ranges);
font_glyph_ranges_builder_clear        :: inline proc(self: ^Font_Glyph_Ranges_Builder)                                   do ImFontGlyphRangesBuilder_Clear(self);
font_glyph_ranges_builder_get_bit      :: inline proc(self: ^Font_Glyph_Ranges_Builder, n: uint) -> bool                  do return ImFontGlyphRangesBuilder_GetBit(self, n);
font_glyph_ranges_builder_set_bit      :: inline proc(self: ^Font_Glyph_Ranges_Builder, n: uint)                          do ImFontGlyphRangesBuilder_SetBit(self, n);

font_add_glyph                 :: inline proc(self: ^ImFont, c: Wchar, x0: f32, y0: f32, x1: f32, y1: f32, u0: f32, v0: f32, u1: f32, v1: f32, advance_x: f32)                                                     do ImFont_AddGlyph(self, c, x0, y0, x1, y1, u0, v0, u1, v1, advance_x);
font_add_remap_char            :: inline proc(self: ^ImFont, dst: Wchar, src: Wchar, overwrite_dst := bool(true))                                                                                                  do ImFont_AddRemapChar(self, dst, src, overwrite_dst);
font_build_lookup_table        :: inline proc(self: ^ImFont)                                                                                                                                                       do ImFont_BuildLookupTable(self);
font_calc_text_size_a          :: inline proc(pOut: ^Vec2, self: ^ImFont, size: f32, max_width: f32, wrap_width: f32, text_begin: string, text_end := "", remaining : ^cstring = nil)                              do swr_ImFont_CalcTextSizeA(pOut, self, size, max_width, wrap_width, text_begin, text_end, remaining);
font_calc_word_wrap_position_a :: inline proc(self: ^ImFont, scale: f32, text: string, text_end: string, wrap_width: f32) -> cstring                                                                               do return swr_ImFont_CalcWordWrapPositionA(self, scale, text, text_end, wrap_width);
font_clear_output_data         :: inline proc(self: ^ImFont)                                                                                                                                                       do ImFont_ClearOutputData(self);
font_find_glyph                :: inline proc(self: ^ImFont, c: Wchar) -> ^Font_Glyph                                                                                                                              do return ImFont_FindGlyph(self, c);
font_find_glyph_no_fallback    :: inline proc(self: ^ImFont, c: Wchar) -> ^Font_Glyph                                                                                                                              do return ImFont_FindGlyphNoFallback(self, c);
font_get_char_advance          :: inline proc(self: ^ImFont, c: Wchar) -> f32                                                                                                                                      do return ImFont_GetCharAdvance(self, c);
font_get_debug_name            :: inline proc(self: ^ImFont) -> cstring                                                                                                                                            do return ImFont_GetDebugName(self);
font_grow_index                :: inline proc(self: ^ImFont, new_size: i32)                                                                                                                                        do ImFont_GrowIndex(self, new_size);
font_is_glyph_range_unused     :: inline proc(self: ^ImFont, c_begin: u32, c_last: u32) -> bool                                                                                                                    do return ImFont_IsGlyphRangeUnused(self, c_begin, c_last);
font_is_loaded                 :: inline proc(self: ^ImFont) -> bool                                                                                                                                               do return ImFont_IsLoaded(self);
font_render_char               :: inline proc(self: ^ImFont, draw_list: ^Draw_List, size: f32, pos: Vec2, col: u32, c: Wchar)                                                                                      do ImFont_RenderChar(self, draw_list, size, pos, col, c);
font_render_text               :: inline proc(self: ^ImFont, draw_list: ^Draw_List, size: f32, pos: Vec2, col: u32, clip_rect: Vec4, text_begin: string, text_end: string, wrap_width := f32(0.0), cpu_fine_clip := bool(false)) do swr_ImFont_RenderText(self, draw_list, size, pos, col, clip_rect, text_begin, text_end, wrap_width, cpu_fine_clip);
font_set_fallback_char         :: inline proc(self: ^ImFont, c: Wchar)                                                                                                                                             do ImFont_SetFallbackChar(self, c);
font_set_glyph_visible         :: inline proc(self: ^ImFont, c: Wchar, visible: bool)                                                                                                                              do ImFont_SetGlyphVisible(self, c, visible);

columns_clear :: inline proc(self: ^Columns) do ImGuiColumns_Clear(self);

io_add_input_character       :: inline proc(self: ^IO, c: u32)       do ImGuiIO_AddInputCharacter(self, c);
io_add_input_character_utf16 :: inline proc(self: ^IO, c: Wchar16)   do ImGuiIO_AddInputCharacterUTF16(self, c);
io_add_input_characters_utf8 :: inline proc(self: ^IO, str: string)  do swr_ImGuiIO_AddInputCharactersUTF8(self, str);
io_clear_input_characters    :: inline proc(self: ^IO)               do ImGuiIO_ClearInputCharacters(self);

input_text_callback_data_delete_chars  :: inline proc(self: ^Input_Text_Callback_Data, pos: i32, bytes_count: i32)                 do ImGuiInputTextCallbackData_DeleteChars(self, pos, bytes_count);
input_text_callback_data_has_selection :: inline proc(self: ^Input_Text_Callback_Data) -> bool                                     do return ImGuiInputTextCallbackData_HasSelection(self);
input_text_callback_data_insert_chars  :: inline proc(self: ^Input_Text_Callback_Data, pos: i32, text: string, text_end := "")     do swr_ImGuiInputTextCallbackData_InsertChars(self, pos, text, text_end);

input_text_state_clear_free_memory    :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_ClearFreeMemory(self);
input_text_state_clear_selection      :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_ClearSelection(self);
input_text_state_clear_text           :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_ClearText(self);
input_text_state_cursor_anim_reset    :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_CursorAnimReset(self);
input_text_state_cursor_clamp         :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_CursorClamp(self);
input_text_state_get_redo_avail_count :: inline proc(self: ^Input_Text_State) -> i32    do return ImGuiInputTextState_GetRedoAvailCount(self);
input_text_state_get_undo_avail_count :: inline proc(self: ^Input_Text_State) -> i32    do return ImGuiInputTextState_GetUndoAvailCount(self);
input_text_state_has_selection        :: inline proc(self: ^Input_Text_State) -> bool   do return ImGuiInputTextState_HasSelection(self);
input_text_state_on_key_pressed       :: inline proc(self: ^Input_Text_State, key: i32) do ImGuiInputTextState_OnKeyPressed(self, key);
input_text_state_select_all           :: inline proc(self: ^Input_Text_State)           do ImGuiInputTextState_SelectAll(self);

item_hovered_data_backup_backup  :: inline proc(self: ^Item_Hovered_Data_Backup) do ImGuiItemHoveredDataBackup_Backup(self);
item_hovered_data_backup_restore :: inline proc(self: ^Item_Hovered_Data_Backup) do ImGuiItemHoveredDataBackup_Restore(self);

list_clipper_begin :: inline proc(self: ^List_Clipper, items_count: i32, items_height := f32(-1.0)) do ImGuiListClipper_Begin(self, items_count, items_height);
list_clipper_end   :: inline proc(self: ^List_Clipper)                                      do ImGuiListClipper_End(self);
list_clipper_step  :: inline proc(self: ^List_Clipper) -> bool                              do return ImGuiListClipper_Step(self);

menu_columns_calc_extra_space :: inline proc(self: ^Menu_Columns, avail_w: f32) -> f32                   do return ImGuiMenuColumns_CalcExtraSpace(self, avail_w);
menu_columns_decl_columns     :: inline proc(self: ^Menu_Columns, w0: f32, w1: f32, w2: f32) -> f32      do return ImGuiMenuColumns_DeclColumns(self, w0, w1, w2);
menu_columns_update           :: inline proc(self: ^Menu_Columns, count: i32, spacing: f32, clear: bool) do ImGuiMenuColumns_Update(self, count, spacing, clear);

nav_move_result_clear :: inline proc(self: ^Nav_Move_Result) do ImGuiNavMoveResult_Clear(self);

next_item_data_clear_flags :: inline proc(self: ^Next_Item_Data) do ImGuiNextItemData_ClearFlags(self);

next_window_data_clear_flags :: inline proc(self: ^Next_Window_Data) do ImGuiNextWindowData_ClearFlags(self);

payload_clear        :: inline proc(self: ^Payload)                        do ImGuiPayload_Clear(self);
payload_is_data_type :: inline proc(self: ^Payload, type: string) -> bool  do return swr_ImGuiPayload_IsDataType(self, type);
payload_is_delivery  :: inline proc(self: ^Payload) -> bool                do return ImGuiPayload_IsDelivery(self);
payload_is_preview   :: inline proc(self: ^Payload) -> bool                do return ImGuiPayload_IsPreview(self);

storage_build_sort_by_key :: inline proc(self: ^Storage)                                            do ImGuiStorage_BuildSortByKey(self);
storage_clear             :: inline proc(self: ^Storage)                                            do ImGuiStorage_Clear(self);
storage_get_bool          :: inline proc(self: ^Storage, key: ImID, default_val := bool(false)) -> bool do return ImGuiStorage_GetBool(self, key, default_val);
storage_get_bool_ref      :: inline proc(self: ^Storage, key: ImID, default_val := bool(false)) -> ^bool do return ImGuiStorage_GetBoolRef(self, key, default_val);
storage_get_float         :: inline proc(self: ^Storage, key: ImID, default_val := f32(0.0)) -> f32 do return ImGuiStorage_GetFloat(self, key, default_val);
storage_get_float_ref     :: inline proc(self: ^Storage, key: ImID, default_val := f32(0.0)) -> ^f32 do return ImGuiStorage_GetFloatRef(self, key, default_val);
storage_get_int           :: inline proc(self: ^Storage, key: ImID, default_val := i32(0)) -> i32   do return ImGuiStorage_GetInt(self, key, default_val);
storage_get_int_ref       :: inline proc(self: ^Storage, key: ImID, default_val := i32(0)) -> ^i32  do return ImGuiStorage_GetIntRef(self, key, default_val);
storage_get_void_ptr      :: inline proc(self: ^Storage, key: ImID) -> rawptr                       do return ImGuiStorage_GetVoidPtr(self, key);
storage_get_void_ptr_ref  :: inline proc(self: ^Storage, key: ImID, default_val : rawptr = nil) -> ^rawptr do return ImGuiStorage_GetVoidPtrRef(self, key, default_val);
storage_set_all_int       :: inline proc(self: ^Storage, val: i32)                                  do ImGuiStorage_SetAllInt(self, val);
storage_set_bool          :: inline proc(self: ^Storage, key: ImID, val: bool)                      do ImGuiStorage_SetBool(self, key, val);
storage_set_float         :: inline proc(self: ^Storage, key: ImID, val: f32)                       do ImGuiStorage_SetFloat(self, key, val);
storage_set_int           :: inline proc(self: ^Storage, key: ImID, val: i32)                       do ImGuiStorage_SetInt(self, key, val);
storage_set_void_ptr      :: inline proc(self: ^Storage, key: ImID, val: rawptr)                    do ImGuiStorage_SetVoidPtr(self, key, val);

style_scale_all_sizes :: inline proc(self: ^Style, scale_factor: f32) do ImGuiStyle_ScaleAllSizes(self, scale_factor);

tab_bar_get_tab_name  :: inline proc(self: ^Tab_Bar, tab: ^Tab_Item) -> cstring do return ImGuiTabBar_GetTabName(self, tab);
tab_bar_get_tab_order :: inline proc(self: ^Tab_Bar, tab: ^Tab_Item) -> i32     do return ImGuiTabBar_GetTabOrder(self, tab);

text_buffer_append  :: inline proc(self: ^Text_Buffer, str: string, str_end := "")           do swr_ImGuiTextBuffer_append(self, str, str_end);
text_buffer_appendf :: inline proc(self: ^Text_Buffer, fmt_: string, args: ..any)            do swr_ImGuiTextBuffer_appendf(self, fmt_, args);
text_buffer_begin   :: inline proc(self: ^Text_Buffer) -> cstring                            do return ImGuiTextBuffer_begin(self);
text_buffer_c_str   :: inline proc(self: ^Text_Buffer) -> cstring                            do return ImGuiTextBuffer_c_str(self);
text_buffer_clear   :: inline proc(self: ^Text_Buffer)                                       do ImGuiTextBuffer_clear(self);
text_buffer_empty   :: inline proc(self: ^Text_Buffer) -> bool                               do return ImGuiTextBuffer_empty(self);
text_buffer_end     :: inline proc(self: ^Text_Buffer) -> cstring                            do return ImGuiTextBuffer_end(self);
text_buffer_reserve :: inline proc(self: ^Text_Buffer, capacity: i32)                        do ImGuiTextBuffer_reserve(self, capacity);
text_buffer_size    :: inline proc(self: ^Text_Buffer) -> i32                                do return ImGuiTextBuffer_size(self);

text_filter_build       :: inline proc(self: ^Text_Filter)                                           do ImGuiTextFilter_Build(self);
text_filter_clear       :: inline proc(self: ^Text_Filter)                                           do ImGuiTextFilter_Clear(self);
text_filter_draw        :: inline proc(self: ^Text_Filter, label := "Filter(inc,-exc)", width := f32(0.0)) -> bool do return swr_ImGuiTextFilter_Draw(self, label, width);
text_filter_is_active   :: inline proc(self: ^Text_Filter) -> bool                                   do return ImGuiTextFilter_IsActive(self);
text_filter_pass_filter :: inline proc(self: ^Text_Filter, text: string, text_end := "") -> bool     do return swr_ImGuiTextFilter_PassFilter(self, text, text_end);

text_range_empty :: inline proc(self: ^Text_Range) -> bool                                     do return ImGuiTextRange_empty(self);
text_range_split :: inline proc(self: ^Text_Range, separator: i8, out: ^Im_Vector(Text_Range)) do ImGuiTextRange_split(self, separator, out);

window_settings_get_name :: inline proc(self: ^Window_Settings) -> cstring do return ImGuiWindowSettings_GetName(self);

window_calc_font_size           :: inline proc(self: ^ImWindow) -> f32                                  do return ImGuiWindow_CalcFontSize(self);

window_get_id :: proc {
	window_get_id_str,
	window_get_id_ptr,
	window_get_id_int,
};
window_get_id_str               :: inline proc(self: ^ImWindow, str: string, str_end := "") -> ImID     do return swr_ImGuiWindow_GetIDStr(self, str, str_end);
window_get_id_ptr               :: inline proc(self: ^ImWindow, ptr: rawptr) -> ImID                    do return ImGuiWindow_GetIDPtr(self, ptr);
window_get_id_int               :: inline proc(self: ^ImWindow, n: i32) -> ImID                         do return ImGuiWindow_GetIDInt(self, n);

window_get_id_from_rectangle    :: inline proc(self: ^ImWindow, r_abs: Rect) -> ImID                    do return ImGuiWindow_GetIDFromRectangle(self, r_abs);

get_id_no_keep_alive :: proc {
	window_get_id_no_keep_alive_str,
	window_get_id_no_keep_alive_ptr,
	window_get_id_no_keep_alive_int,
};
window_get_id_no_keep_alive_str :: inline proc(self: ^ImWindow, str: string, str_end := "") -> ImID     do return swr_ImGuiWindow_GetIDNoKeepAliveStr(self, str, str_end);
window_get_id_no_keep_alive_ptr :: inline proc(self: ^ImWindow, ptr: rawptr) -> ImID                    do return ImGuiWindow_GetIDNoKeepAlivePtr(self, ptr);
window_get_id_no_keep_alive_int :: inline proc(self: ^ImWindow, n: i32) -> ImID                         do return ImGuiWindow_GetIDNoKeepAliveInt(self, n);

window_menu_bar_height          :: inline proc(self: ^ImWindow) -> f32                                  do return ImGuiWindow_MenuBarHeight(self);
window_menu_bar_rect            :: inline proc(pOut: ^Rect, self: ^ImWindow)                            do ImGuiWindow_MenuBarRect(pOut, self);
window_rect                     :: inline proc(pOut: ^Rect, self: ^ImWindow)                            do ImGuiWindow_Rect(pOut, self);
window_title_bar_height         :: inline proc(self: ^ImWindow) -> f32                                  do return ImGuiWindow_TitleBarHeight(self);
window_title_bar_rect           :: inline proc(pOut: ^Rect, self: ^ImWindow)                            do ImGuiWindow_TitleBarRect(pOut, self);


add :: proc {
	rect_add_vec2,
	rect_add_rect,
};
rect_add_vec2       :: inline proc(self: ^Rect, p: Vec2)         do ImRect_AddVec2(self, p);
rect_add_rect       :: inline proc(self: ^Rect, r: Rect)         do ImRect_AddRect(self, r);

rect_clip_with      :: inline proc(self: ^Rect, r: Rect)         do ImRect_ClipWith(self, r);
rect_clip_with_full :: inline proc(self: ^Rect, r: Rect)         do ImRect_ClipWithFull(self, r);

contains :: proc {
	rect_contains_vec2,
	rect_contains_rect,
};
rect_contains_vec2  :: inline proc(self: ^Rect, p: Vec2) -> bool do return ImRect_ContainsVec2(self, p);
rect_contains_rect  :: inline proc(self: ^Rect, r: Rect) -> bool do return ImRect_ContainsRect(self, r);


expand :: proc {
	rect_expand_float,
	rect_expand_vec2,
};
rect_expand_float   :: inline proc(self: ^Rect, amount: f32)     do ImRect_ExpandFloat(self, amount);
rect_expand_vec2    :: inline proc(self: ^Rect, amount: Vec2)    do ImRect_ExpandVec2(self, amount);

rect_floor          :: inline proc(self: ^Rect)                  do ImRect_Floor(self);
rect_get_bl         :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetBL(pOut, self);
rect_get_br         :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetBR(pOut, self);
rect_get_center     :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetCenter(pOut, self);
rect_get_height     :: inline proc(self: ^Rect) -> f32           do return ImRect_GetHeight(self);
rect_get_size       :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetSize(pOut, self);
rect_get_tl         :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetTL(pOut, self);
rect_get_tr         :: inline proc(pOut: ^Vec2, self: ^Rect)     do ImRect_GetTR(pOut, self);
rect_get_width      :: inline proc(self: ^Rect) -> f32           do return ImRect_GetWidth(self);
rect_is_inverted    :: inline proc(self: ^Rect) -> bool          do return ImRect_IsInverted(self);
rect_overlaps       :: inline proc(self: ^Rect, r: Rect) -> bool do return ImRect_Overlaps(self, r);
rect_translate      :: inline proc(self: ^Rect, d: Vec2)         do ImRect_Translate(self, d);
rect_translate_x    :: inline proc(self: ^Rect, dx: f32)         do ImRect_TranslateX(self, dx);
rect_translate_y    :: inline proc(self: ^Rect, dy: f32)         do ImRect_TranslateY(self, dy);

accept_drag_drop_payload                       :: inline proc(type: string, flags := Drag_Drop_Flags(0)) -> ^Payload                                                                                                                                              do return swr_igAcceptDragDropPayload(type, flags);
activate_item                                  :: inline proc(id: ImID)                                                                                                                                                                                           do igActivateItem(id);
align_text_to_frame_padding                    :: inline proc()                                                                                                                                                                                                   do igAlignTextToFramePadding();
arrow_button                                   :: inline proc(str_id: string, dir: Dir) -> bool                                                                                                                                                                   do return swr_igArrowButton(str_id, dir);
arrow_button_ex                                :: inline proc(str_id: string, dir: Dir, size_arg: Vec2, flags := Button_Flags(0)) -> bool                                                                                                                         do return swr_igArrowButtonEx(str_id, dir, size_arg, flags);
begin                                          :: inline proc(name: string, p_open : ^bool = nil, flags := Window_Flags(0)) -> bool                                                                                                                               do return swr_igBegin(name, p_open, flags);

begin_child :: proc {
	begin_child_str,
	begin_child_id,
};
begin_child_str                                :: inline proc(str_id: string, size := Vec2(Vec2{0,0}), border := bool(false), flags := Window_Flags(0)) -> bool                                                                                                   do return swr_igBeginChildStr(str_id, size, border, flags);
begin_child_id                                 :: inline proc(id: ImID, size := Vec2(Vec2{0,0}), border := bool(false), flags := Window_Flags(0)) -> bool                                                                                                         do return igBeginChildID(id, size, border, flags);

begin_child_ex                                 :: inline proc(name: string, id: ImID, size_arg: Vec2, border: bool, flags: Window_Flags) -> bool                                                                                                                  do return swr_igBeginChildEx(name, id, size_arg, border, flags);
begin_child_frame                              :: inline proc(id: ImID, size: Vec2, flags := Window_Flags(0)) -> bool                                                                                                                                             do return igBeginChildFrame(id, size, flags);
begin_columns                                  :: inline proc(str_id: string, count: i32, flags := Columns_Flags(0))                                                                                                                                              do swr_igBeginColumns(str_id, count, flags);
begin_combo                                    :: inline proc(label: string, preview_value: string, flags := Combo_Flags(0)) -> bool                                                                                                                              do return swr_igBeginCombo(label, preview_value, flags);
begin_drag_drop_source                         :: inline proc(flags := Drag_Drop_Flags(0)) -> bool                                                                                                                                                                do return igBeginDragDropSource(flags);
begin_drag_drop_target                         :: inline proc() -> bool                                                                                                                                                                                           do return igBeginDragDropTarget();
begin_drag_drop_target_custom                  :: inline proc(bb: Rect, id: ImID) -> bool                                                                                                                                                                         do return igBeginDragDropTargetCustom(bb, id);
begin_group                                    :: inline proc()                                                                                                                                                                                                   do igBeginGroup();
begin_main_menu_bar                            :: inline proc() -> bool                                                                                                                                                                                           do return igBeginMainMenuBar();
begin_menu                                     :: inline proc(label: string, enabled := bool(true)) -> bool                                                                                                                                                       do return swr_igBeginMenu(label, enabled);
begin_menu_bar                                 :: inline proc() -> bool                                                                                                                                                                                           do return igBeginMenuBar();
begin_popup                                    :: inline proc(str_id: string, flags := Window_Flags(0)) -> bool                                                                                                                                                   do return swr_igBeginPopup(str_id, flags);
begin_popup_context_item                       :: inline proc(str_id := "", mouse_button := Mouse_Button(1)) -> bool                                                                                                                                              do return swr_igBeginPopupContextItem(str_id, mouse_button);
begin_popup_context_void                       :: inline proc(str_id := "", mouse_button := Mouse_Button(1)) -> bool                                                                                                                                              do return swr_igBeginPopupContextVoid(str_id, mouse_button);
begin_popup_context_window                     :: inline proc(str_id := "", mouse_button := Mouse_Button(1), also_over_items := bool(true)) -> bool                                                                                                               do return swr_igBeginPopupContextWindow(str_id, mouse_button, also_over_items);
begin_popup_ex                                 :: inline proc(id: ImID, extra_flags: Window_Flags) -> bool                                                                                                                                                        do return igBeginPopupEx(id, extra_flags);
begin_popup_modal                              :: inline proc(name: string, p_open : ^bool = nil, flags := Window_Flags(0)) -> bool                                                                                                                               do return swr_igBeginPopupModal(name, p_open, flags);
begin_tab_bar                                  :: inline proc(str_id: string, flags := Tab_Bar_Flags(0)) -> bool                                                                                                                                                  do return swr_igBeginTabBar(str_id, flags);
begin_tab_bar_ex                               :: inline proc(tab_bar: ^Tab_Bar, bb: Rect, flags: Tab_Bar_Flags) -> bool                                                                                                                                          do return igBeginTabBarEx(tab_bar, bb, flags);
begin_tab_item                                 :: inline proc(label: string, p_open : ^bool = nil, flags := Tab_Item_Flags(0)) -> bool                                                                                                                            do return swr_igBeginTabItem(label, p_open, flags);
begin_tooltip                                  :: inline proc()                                                                                                                                                                                                   do igBeginTooltip();
begin_tooltip_ex                               :: inline proc(extra_flags: Window_Flags, tooltip_flags: Tooltip_Flags)                                                                                                                                            do igBeginTooltipEx(extra_flags, tooltip_flags);
bring_window_to_display_back                   :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igBringWindowToDisplayBack(window);
bring_window_to_display_front                  :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igBringWindowToDisplayFront(window);
bring_window_to_focus_front                    :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igBringWindowToFocusFront(window);
bullet                                         :: inline proc()                                                                                                                                                                                                   do igBullet();
bullet_text                                    :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do swr_igBulletText(fmt_, args);
button                                         :: inline proc(label: string, size := Vec2(Vec2{0,0})) -> bool                                                                                                                                                     do return swr_igButton(label, size);
button_behavior                                :: inline proc(bb: Rect, id: ImID, out_hovered: ^bool, out_held: ^bool, flags := Button_Flags(0)) -> bool                                                                                                          do return igButtonBehavior(bb, id, out_hovered, out_held, flags);
button_ex                                      :: inline proc(label: string, size_arg := Vec2(Vec2{0,0}), flags := Button_Flags(0)) -> bool                                                                                                                       do return swr_igButtonEx(label, size_arg, flags);
calc_item_size                                 :: inline proc(pOut: ^Vec2, size: Vec2, default_w: f32, default_h: f32)                                                                                                                                            do igCalcItemSize(pOut, size, default_w, default_h);
calc_item_width                                :: inline proc() -> f32                                                                                                                                                                                            do return igCalcItemWidth();
calc_list_clipping                             :: inline proc(items_count: i32, items_height: f32, out_items_display_start: ^i32, out_items_display_end: ^i32)                                                                                                    do igCalcListClipping(items_count, items_height, out_items_display_start, out_items_display_end);
calc_text_size                                 :: inline proc(pOut: ^Vec2, text: string, text_end := "", hide_text_after_double_hash := bool(false), wrap_width := f32(-1.0))                                                                                     do swr_igCalcTextSize(pOut, text, text_end, hide_text_after_double_hash, wrap_width);
calc_typematic_repeat_amount                   :: inline proc(t0: f32, t1: f32, repeat_delay: f32, repeat_rate: f32) -> i32                                                                                                                                       do return igCalcTypematicRepeatAmount(t0, t1, repeat_delay, repeat_rate);
calc_window_expected_size                      :: inline proc(pOut: ^Vec2, window: ^ImWindow)                                                                                                                                                                     do igCalcWindowExpectedSize(pOut, window);
calc_wrap_width_for_pos                        :: inline proc(pos: Vec2, wrap_pos_x: f32) -> f32                                                                                                                                                                  do return igCalcWrapWidthForPos(pos, wrap_pos_x);
capture_keyboard_from_app                      :: inline proc(want_capture_keyboard_value := bool(true))                                                                                                                                                          do igCaptureKeyboardFromApp(want_capture_keyboard_value);
capture_mouse_from_app                         :: inline proc(want_capture_mouse_value := bool(true))                                                                                                                                                             do igCaptureMouseFromApp(want_capture_mouse_value);
checkbox                                       :: inline proc(label: string, v: ^bool) -> bool                                                                                                                                                                    do return swr_igCheckbox(label, v);
checkbox_flags                                 :: inline proc(label: string, flags: ^u32, flags_value: u32) -> bool                                                                                                                                               do return swr_igCheckboxFlags(label, flags, flags_value);
clear_active_id                                :: inline proc()                                                                                                                                                                                                   do igClearActiveID();
clear_drag_drop                                :: inline proc()                                                                                                                                                                                                   do igClearDragDrop();
close_button                                   :: inline proc(id: ImID, pos: Vec2) -> bool                                                                                                                                                                        do return igCloseButton(id, pos);
close_current_popup                            :: inline proc()                                                                                                                                                                                                   do igCloseCurrentPopup();
close_popup_to_level                           :: inline proc(remaining: i32, restore_focus_to_window_under_popup: bool)                                                                                                                                          do igClosePopupToLevel(remaining, restore_focus_to_window_under_popup);
close_popups_over_window                       :: inline proc(ref_window: ^ImWindow, restore_focus_to_window_under_popup: bool)                                                                                                                                   do igClosePopupsOverWindow(ref_window, restore_focus_to_window_under_popup);
collapse_button                                :: inline proc(id: ImID, pos: Vec2) -> bool                                                                                                                                                                        do return igCollapseButton(id, pos);

collapsing_header :: proc {
	collapsing_header_tree_node_flags,
	collapsing_header_bool_ptr,
};
collapsing_header_tree_node_flags              :: inline proc(label: string, flags := Tree_Node_Flags(0)) -> bool                                                                                                                                                 do return swr_igCollapsingHeaderTreeNodeFlags(label, flags);
collapsing_header_bool_ptr                     :: inline proc(label: string, p_open: ^bool, flags := Tree_Node_Flags(0)) -> bool                                                                                                                                  do return swr_igCollapsingHeaderBoolPtr(label, p_open, flags);

color_button                                   :: inline proc(desc_id: string, col: Vec4, flags := Color_Edit_Flags(0), size := Vec2(Vec2{0,0})) -> bool                                                                                                          do return swr_igColorButton(desc_id, col, flags, size);
color_convert_float4to_u32                     :: inline proc(in_: Vec4) -> u32                                                                                                                                                                                   do return igColorConvertFloat4ToU32(in_);
color_convert_hs_vto_rgb                       :: inline proc(h: f32, s: f32, v: f32, out_r: ^f32, out_g: ^f32, out_b: ^f32)                                                                                                                                      do igColorConvertHSVtoRGB(h, s, v, out_r, out_g, out_b);
color_convert_rg_bto_hsv                       :: inline proc(r: f32, g: f32, b: f32, out_h: ^f32, out_s: ^f32, out_v: ^f32)                                                                                                                                      do igColorConvertRGBtoHSV(r, g, b, out_h, out_s, out_v);
color_convert_u32to_float4                     :: inline proc(pOut: ^Vec4, in_: u32)                                                                                                                                                                              do igColorConvertU32ToFloat4(pOut, in_);
color_edit3                                    :: inline proc(label: string, col: [3]f32, flags := Color_Edit_Flags(0)) -> bool                                                                                                                                   do return swr_igColorEdit3(label, col, flags);
color_edit4                                    :: inline proc(label: string, col: [4]f32, flags := Color_Edit_Flags(0)) -> bool                                                                                                                                   do return swr_igColorEdit4(label, col, flags);
color_edit_options_popup                       :: inline proc(col: ^f32, flags: Color_Edit_Flags)                                                                                                                                                                 do igColorEditOptionsPopup(col, flags);
color_picker3                                  :: inline proc(label: string, col: [3]f32, flags := Color_Edit_Flags(0)) -> bool                                                                                                                                   do return swr_igColorPicker3(label, col, flags);
color_picker4                                  :: inline proc(label: string, col: [4]f32, flags := Color_Edit_Flags(0), ref_col : ^f32 = nil) -> bool                                                                                                             do return swr_igColorPicker4(label, col, flags, ref_col);
color_picker_options_popup                     :: inline proc(ref_col: ^f32, flags: Color_Edit_Flags)                                                                                                                                                             do igColorPickerOptionsPopup(ref_col, flags);
color_tooltip                                  :: inline proc(text: string, col: ^f32, flags: Color_Edit_Flags)                                                                                                                                                   do swr_igColorTooltip(text, col, flags);
columns                                        :: inline proc(count := i32(1), id := "", border := bool(true))                                                                                                                                                    do swr_igColumns(count, id, border);

combo :: proc {
	combo_str_arr,
	combo_str,
	combo_fn_ptr,
};
combo_str_arr                                  :: inline proc(label: string, current_item: ^i32, items: []string, popup_max_height_in_items := i32(0)) -> bool                                                                                                    do return wrapper_combo_str_arr(label, current_item, items, popup_max_height_in_items);
combo_str                                      :: inline proc(label: string, current_item: ^i32, items_separated_by_zeros: string, popup_max_height_in_items := i32(-1)) -> bool                                                                                  do return swr_igComboStr(label, current_item, items_separated_by_zeros, popup_max_height_in_items);
combo_fn_ptr                                   :: inline proc(label: string, current_item: ^i32, items_getter: Items_Getter_Proc, data: rawptr, items_count: i32, popup_max_height_in_items := i32(0)) -> bool                                                    do return wrapper_combo_fn_ptr(label, current_item, items_getter, data, items_count, popup_max_height_in_items);

create_context                                 :: inline proc(shared_font_atlas : ^Font_Atlas = nil) -> ^Context                                                                                                                                                  do return igCreateContext(shared_font_atlas);
create_new_window_settings                     :: inline proc(name: string) -> ^Window_Settings                                                                                                                                                                   do return swr_igCreateNewWindowSettings(name);
data_type_apply_op                             :: inline proc(data_type: Data_Type, op: i32, output: rawptr, arg_1: rawptr, arg_2: rawptr)                                                                                                                        do igDataTypeApplyOp(data_type, op, output, arg_1, arg_2);
data_type_apply_op_from_text                   :: inline proc(buf: string, initial_value_buf: string, data_type: Data_Type, p_data: rawptr, format: string) -> bool                                                                                               do return swr_igDataTypeApplyOpFromText(buf, initial_value_buf, data_type, p_data, format);
data_type_format_string                        :: inline proc(buf: string, buf_size: i32, data_type: Data_Type, p_data: rawptr, format: string) -> i32                                                                                                            do return swr_igDataTypeFormatString(buf, buf_size, data_type, p_data, format);
data_type_get_info                             :: inline proc(data_type: Data_Type) -> ^Data_Type_Info                                                                                                                                                            do return igDataTypeGetInfo(data_type);
debug_check_version_and_data_layout            :: inline proc(version_str: string, sz_io: uint, sz_style: uint, sz_vec2: uint, sz_vec4: uint, sz_drawvert: uint, sz_drawidx: uint) -> bool                                                                        do return swr_igDebugCheckVersionAndDataLayout(version_str, sz_io, sz_style, sz_vec2, sz_vec4, sz_drawvert, sz_drawidx);
debug_draw_item_rect                           :: inline proc(col: u32)                                                                                                                                                                                           do igDebugDrawItemRect(col);
debug_start_item_picker                        :: inline proc()                                                                                                                                                                                                   do igDebugStartItemPicker();
destroy_context                                :: inline proc(ctx : ^Context = nil)                                                                                                                                                                               do igDestroyContext(ctx);
drag_behavior                                  :: inline proc(id: ImID, data_type: Data_Type, p_v: rawptr, v_speed: f32, p_min: rawptr, p_max: rawptr, format: string, power: f32, flags: Drag_Flags) -> bool                                                     do return swr_igDragBehavior(id, data_type, p_v, v_speed, p_min, p_max, format, power, flags);
drag_float                                     :: inline proc(label: string, v: ^f32, v_speed := f32(1.0), v_min := f32(0.0), v_max := f32(0.0), format := "%.3f", power := f32(1.0)) -> bool                                                                     do return swr_igDragFloat(label, v, v_speed, v_min, v_max, format, power);
drag_float2                                    :: inline proc(label: string, v: [2]f32, v_speed := f32(1.0), v_min := f32(0.0), v_max := f32(0.0), format := "%.3f", power := f32(1.0)) -> bool                                                                   do return swr_igDragFloat2(label, v, v_speed, v_min, v_max, format, power);
drag_float3                                    :: inline proc(label: string, v: [3]f32, v_speed := f32(1.0), v_min := f32(0.0), v_max := f32(0.0), format := "%.3f", power := f32(1.0)) -> bool                                                                   do return swr_igDragFloat3(label, v, v_speed, v_min, v_max, format, power);
drag_float4                                    :: inline proc(label: string, v: [4]f32, v_speed := f32(1.0), v_min := f32(0.0), v_max := f32(0.0), format := "%.3f", power := f32(1.0)) -> bool                                                                   do return swr_igDragFloat4(label, v, v_speed, v_min, v_max, format, power);
drag_float_range2                              :: inline proc(label: string, v_current_min: ^f32, v_current_max: ^f32, v_speed := f32(1.0), v_min := f32(0.0), v_max := f32(0.0), format := "%.3f", format_max := "", power := f32(1.0)) -> bool                  do return swr_igDragFloatRange2(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max, power);
drag_int                                       :: inline proc(label: string, v: ^i32, v_speed := f32(1.0), v_min := i32(0), v_max := i32(0), format := "%d") -> bool                                                                                              do return swr_igDragInt(label, v, v_speed, v_min, v_max, format);
drag_int2                                      :: inline proc(label: string, v: [2]i32, v_speed := f32(1.0), v_min := i32(0), v_max := i32(0), format := "%d") -> bool                                                                                            do return swr_igDragInt2(label, v, v_speed, v_min, v_max, format);
drag_int3                                      :: inline proc(label: string, v: [3]i32, v_speed := f32(1.0), v_min := i32(0), v_max := i32(0), format := "%d") -> bool                                                                                            do return swr_igDragInt3(label, v, v_speed, v_min, v_max, format);
drag_int4                                      :: inline proc(label: string, v: [4]i32, v_speed := f32(1.0), v_min := i32(0), v_max := i32(0), format := "%d") -> bool                                                                                            do return swr_igDragInt4(label, v, v_speed, v_min, v_max, format);
drag_int_range2                                :: inline proc(label: string, v_current_min: ^i32, v_current_max: ^i32, v_speed := f32(1.0), v_min := i32(0), v_max := i32(0), format := "%d", format_max := "") -> bool                                           do return swr_igDragIntRange2(label, v_current_min, v_current_max, v_speed, v_min, v_max, format, format_max);
drag_scalar                                    :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, v_speed: f32, p_min : rawptr = nil, p_max : rawptr = nil, format := "", power := f32(1.0)) -> bool                                             do return swr_igDragScalar(label, data_type, p_data, v_speed, p_min, p_max, format, power);
drag_scalar_n                                  :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, v_speed: f32, p_min : rawptr = nil, p_max : rawptr = nil, format := "", power := f32(1.0)) -> bool                            do return swr_igDragScalarN(label, data_type, p_data, components, v_speed, p_min, p_max, format, power);
dummy                                          :: inline proc(size: Vec2)                                                                                                                                                                                         do igDummy(size);
end                                            :: inline proc()                                                                                                                                                                                                   do igEnd();
end_child                                      :: inline proc()                                                                                                                                                                                                   do igEndChild();
end_child_frame                                :: inline proc()                                                                                                                                                                                                   do igEndChildFrame();
end_columns                                    :: inline proc()                                                                                                                                                                                                   do igEndColumns();
end_combo                                      :: inline proc()                                                                                                                                                                                                   do igEndCombo();
end_drag_drop_source                           :: inline proc()                                                                                                                                                                                                   do igEndDragDropSource();
end_drag_drop_target                           :: inline proc()                                                                                                                                                                                                   do igEndDragDropTarget();
end_frame                                      :: inline proc()                                                                                                                                                                                                   do igEndFrame();
end_group                                      :: inline proc()                                                                                                                                                                                                   do igEndGroup();
end_main_menu_bar                              :: inline proc()                                                                                                                                                                                                   do igEndMainMenuBar();
end_menu                                       :: inline proc()                                                                                                                                                                                                   do igEndMenu();
end_menu_bar                                   :: inline proc()                                                                                                                                                                                                   do igEndMenuBar();
end_popup                                      :: inline proc()                                                                                                                                                                                                   do igEndPopup();
end_tab_bar                                    :: inline proc()                                                                                                                                                                                                   do igEndTabBar();
end_tab_item                                   :: inline proc()                                                                                                                                                                                                   do igEndTabItem();
end_tooltip                                    :: inline proc()                                                                                                                                                                                                   do igEndTooltip();
find_best_window_pos_for_popup                 :: inline proc(pOut: ^Vec2, window: ^ImWindow)                                                                                                                                                                     do igFindBestWindowPosForPopup(pOut, window);
find_best_window_pos_for_popup_ex              :: inline proc(pOut: ^Vec2, ref_pos: Vec2, size: Vec2, last_dir: ^Dir, r_outer: Rect, r_avoid: Rect, policy := Popup_Position_Policy(Popup_Position_Policy.Default))                                               do igFindBestWindowPosForPopupEx(pOut, ref_pos, size, last_dir, r_outer, r_avoid, policy);
find_or_create_columns                         :: inline proc(window: ^ImWindow, id: ImID) -> ^Columns                                                                                                                                                            do return igFindOrCreateColumns(window, id);
find_or_create_window_settings                 :: inline proc(name: string) -> ^Window_Settings                                                                                                                                                                   do return swr_igFindOrCreateWindowSettings(name);
find_rendered_text_end                         :: inline proc(text: string, text_end := "") -> cstring                                                                                                                                                            do return swr_igFindRenderedTextEnd(text, text_end);
find_settings_handler                          :: inline proc(type_name: string) -> ^Settings_Handler                                                                                                                                                             do return swr_igFindSettingsHandler(type_name);
find_window_by_id                              :: inline proc(id: ImID) -> ^ImWindow                                                                                                                                                                              do return igFindWindowByID(id);
find_window_by_name                            :: inline proc(name: string) -> ^ImWindow                                                                                                                                                                          do return swr_igFindWindowByName(name);
find_window_settings                           :: inline proc(id: ImID) -> ^Window_Settings                                                                                                                                                                       do return igFindWindowSettings(id);
focus_top_most_window_under_one                :: inline proc(under_this_window: ^ImWindow, ignore_window: ^ImWindow)                                                                                                                                             do igFocusTopMostWindowUnderOne(under_this_window, ignore_window);
focus_window                                   :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igFocusWindow(window);
focusable_item_register                        :: inline proc(window: ^ImWindow, id: ImID) -> bool                                                                                                                                                                do return igFocusableItemRegister(window, id);
focusable_item_unregister                      :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igFocusableItemUnregister(window);
gc_awake_transient_window_buffers              :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igGcAwakeTransientWindowBuffers(window);
gc_compact_transient_window_buffers            :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igGcCompactTransientWindowBuffers(window);
get_active_id                                  :: inline proc() -> ImID                                                                                                                                                                                           do return igGetActiveID();
get_background_draw_list                       :: inline proc() -> ^Draw_List                                                                                                                                                                                     do return igGetBackgroundDrawList();
get_clipboard_text                             :: inline proc() -> cstring                                                                                                                                                                                        do return igGetClipboardText();

get_color_u32 :: proc {
	get_color_u32col,
	get_color_u32vec4,
	get_color_u32u32,
};
get_color_u32col                               :: inline proc(idx: Col, alpha_mul := f32(1.0)) -> u32                                                                                                                                                             do return igGetColorU32Col(idx, alpha_mul);
get_color_u32vec4                              :: inline proc(col: Vec4) -> u32                                                                                                                                                                                   do return igGetColorU32Vec4(col);
get_color_u32u32                               :: inline proc(col: u32) -> u32                                                                                                                                                                                    do return igGetColorU32U32(col);

get_column_index                               :: inline proc() -> i32                                                                                                                                                                                            do return igGetColumnIndex();
get_column_norm_from_offset                    :: inline proc(columns: ^Columns, offset: f32) -> f32                                                                                                                                                              do return igGetColumnNormFromOffset(columns, offset);
get_column_offset                              :: inline proc(column_index := i32(-1)) -> f32                                                                                                                                                                     do return igGetColumnOffset(column_index);
get_column_offset_from_norm                    :: inline proc(columns: ^Columns, offset_norm: f32) -> f32                                                                                                                                                         do return igGetColumnOffsetFromNorm(columns, offset_norm);
get_column_width                               :: inline proc(column_index := i32(-1)) -> f32                                                                                                                                                                     do return igGetColumnWidth(column_index);
get_columns_count                              :: inline proc() -> i32                                                                                                                                                                                            do return igGetColumnsCount();
get_columns_id                                 :: inline proc(str_id: string, count: i32) -> ImID                                                                                                                                                                 do return swr_igGetColumnsID(str_id, count);
get_content_region_avail                       :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetContentRegionAvail(pOut);
get_content_region_max                         :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetContentRegionMax(pOut);
get_content_region_max_abs                     :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetContentRegionMaxAbs(pOut);
get_current_context                            :: inline proc() -> ^Context                                                                                                                                                                                       do return igGetCurrentContext();
get_current_window                             :: inline proc() -> ^ImWindow                                                                                                                                                                                      do return igGetCurrentWindow();
get_current_window_read                        :: inline proc() -> ^ImWindow                                                                                                                                                                                      do return igGetCurrentWindowRead();
get_cursor_pos                                 :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetCursorPos(pOut);
get_cursor_pos_x                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetCursorPosX();
get_cursor_pos_y                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetCursorPosY();
get_cursor_screen_pos                          :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetCursorScreenPos(pOut);
get_cursor_start_pos                           :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetCursorStartPos(pOut);
get_default_font                               :: inline proc() -> ^ImFont                                                                                                                                                                                        do return igGetDefaultFont();
get_drag_drop_payload                          :: inline proc() -> ^Payload                                                                                                                                                                                       do return igGetDragDropPayload();
get_draw_data                                  :: inline proc() -> ^Draw_Data                                                                                                                                                                                     do return igGetDrawData();
get_draw_list_shared_data                      :: inline proc() -> ^Draw_List_Shared_Data                                                                                                                                                                         do return igGetDrawListSharedData();
get_focus_id                                   :: inline proc() -> ImID                                                                                                                                                                                           do return igGetFocusID();
get_focus_scope_id                             :: inline proc() -> ImID                                                                                                                                                                                           do return igGetFocusScopeID();
get_font                                       :: inline proc() -> ^ImFont                                                                                                                                                                                        do return igGetFont();
get_font_size                                  :: inline proc() -> f32                                                                                                                                                                                            do return igGetFontSize();
get_font_tex_uv_white_pixel                    :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetFontTexUvWhitePixel(pOut);

get_foreground_draw_list :: proc {
	get_foreground_draw_list_nil,
	get_foreground_draw_list_window_ptr,
};
get_foreground_draw_list_nil                   :: inline proc() -> ^Draw_List                                                                                                                                                                                     do return igGetForegroundDrawListNil();
get_foreground_draw_list_window_ptr            :: inline proc(window: ^ImWindow) -> ^Draw_List                                                                                                                                                                    do return igGetForegroundDrawListWindowPtr(window);

get_frame_count                                :: inline proc() -> i32                                                                                                                                                                                            do return igGetFrameCount();
get_frame_height                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetFrameHeight();
get_frame_height_with_spacing                  :: inline proc() -> f32                                                                                                                                                                                            do return igGetFrameHeightWithSpacing();
get_hovered_id                                 :: inline proc() -> ImID                                                                                                                                                                                           do return igGetHoveredID();

get_id :: proc {
	get_id_str,
	get_id_str_str,
	get_id_ptr,
};
get_id_str                                     :: inline proc(str_id: string) -> ImID                                                                                                                                                                             do return swr_igGetIDStr(str_id);
get_id_str_str                                 :: inline proc(str_id_begin: string, str_id_end: string) -> ImID                                                                                                                                                   do return swr_igGetIDStrStr(str_id_begin, str_id_end);
get_id_ptr                                     :: inline proc(ptr_id: rawptr) -> ImID                                                                                                                                                                             do return igGetIDPtr(ptr_id);

get_io                                         :: inline proc() -> ^IO                                                                                                                                                                                            do return igGetIO();
get_input_text_state                           :: inline proc(id: ImID) -> ^Input_Text_State                                                                                                                                                                      do return igGetInputTextState(id);
get_item_id                                    :: inline proc() -> ImID                                                                                                                                                                                           do return igGetItemID();
get_item_rect_max                              :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetItemRectMax(pOut);
get_item_rect_min                              :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetItemRectMin(pOut);
get_item_rect_size                             :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetItemRectSize(pOut);
get_item_status_flags                          :: inline proc() -> Item_Status_Flags                                                                                                                                                                              do return igGetItemStatusFlags();
get_key_index                                  :: inline proc(imgui_key: Key) -> i32                                                                                                                                                                              do return igGetKeyIndex(imgui_key);
get_key_pressed_amount                         :: inline proc(key_index: i32, repeat_delay: f32, rate: f32) -> i32                                                                                                                                                do return igGetKeyPressedAmount(key_index, repeat_delay, rate);
get_merged_key_mod_flags                       :: inline proc() -> Key_Mod_Flags                                                                                                                                                                                  do return igGetMergedKeyModFlags();
get_mouse_cursor                               :: inline proc() -> Mouse_Cursor                                                                                                                                                                                   do return igGetMouseCursor();
get_mouse_drag_delta                           :: inline proc(pOut: ^Vec2, button := Mouse_Button(0), lock_threshold := f32(-1.0))                                                                                                                                do igGetMouseDragDelta(pOut, button, lock_threshold);
get_mouse_pos                                  :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetMousePos(pOut);
get_mouse_pos_on_opening_current_popup         :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetMousePosOnOpeningCurrentPopup(pOut);
get_nav_input_amount                           :: inline proc(n: Nav_Input, mode: Input_Read_Mode) -> f32                                                                                                                                                         do return igGetNavInputAmount(n, mode);
get_nav_input_amount2d                         :: inline proc(pOut: ^Vec2, dir_sources: Nav_Dir_Source_Flags, mode: Input_Read_Mode, slow_factor := f32(0.0), fast_factor := f32(0.0))                                                                            do igGetNavInputAmount2d(pOut, dir_sources, mode, slow_factor, fast_factor);
get_scroll_max_x                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetScrollMaxX();
get_scroll_max_y                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetScrollMaxY();
get_scroll_x                                   :: inline proc() -> f32                                                                                                                                                                                            do return igGetScrollX();
get_scroll_y                                   :: inline proc() -> f32                                                                                                                                                                                            do return igGetScrollY();
get_state_storage                              :: inline proc() -> ^Storage                                                                                                                                                                                       do return igGetStateStorage();
get_style                                      :: inline proc() -> ^Style                                                                                                                                                                                         do return igGetStyle();
get_style_color_name                           :: inline proc(idx: Col) -> cstring                                                                                                                                                                                do return igGetStyleColorName(idx);
get_style_color_vec4                           :: inline proc(idx: Col) -> ^Vec4                                                                                                                                                                                  do return igGetStyleColorVec4(idx);
get_text_line_height                           :: inline proc() -> f32                                                                                                                                                                                            do return igGetTextLineHeight();
get_text_line_height_with_spacing              :: inline proc() -> f32                                                                                                                                                                                            do return igGetTextLineHeightWithSpacing();
get_time                                       :: inline proc() -> f64                                                                                                                                                                                            do return igGetTime();
get_top_most_popup_modal                       :: inline proc() -> ^ImWindow                                                                                                                                                                                      do return igGetTopMostPopupModal();
get_tree_node_to_label_spacing                 :: inline proc() -> f32                                                                                                                                                                                            do return igGetTreeNodeToLabelSpacing();
get_version                                    :: inline proc() -> cstring                                                                                                                                                                                        do return igGetVersion();
get_window_allowed_extent_rect                 :: inline proc(pOut: ^Rect, window: ^ImWindow)                                                                                                                                                                     do igGetWindowAllowedExtentRect(pOut, window);
get_window_content_region_max                  :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetWindowContentRegionMax(pOut);
get_window_content_region_min                  :: inline proc(pOut: ^Vec2)                                                                                                                                                                                        do igGetWindowContentRegionMin(pOut);
get_window_content_region_width                :: inline proc() -> f32                                                                                                                                                                                            do return igGetWindowContentRegionWidth();
get_window_draw_list                           :: inline proc() -> ^Draw_List                                                                                                                                                                                     do return igGetWindowDrawList();
get_window_height                              :: inline proc() -> f32                                                                                                                                                                                            do return igGetWindowHeight();
get_window_pos                                 :: inline proc() -> Vec2                                                                                                                                                                                           do return wrapper_get_window_pos();
get_window_resize_id                           :: inline proc(window: ^ImWindow, n: i32) -> ImID                                                                                                                                                                  do return igGetWindowResizeID(window, n);
get_window_scrollbar_id                        :: inline proc(window: ^ImWindow, axis: Axis) -> ImID                                                                                                                                                              do return igGetWindowScrollbarID(window, axis);
get_window_scrollbar_rect                      :: inline proc(pOut: ^Rect, window: ^ImWindow, axis: Axis)                                                                                                                                                         do igGetWindowScrollbarRect(pOut, window, axis);
get_window_size                                :: inline proc() -> Vec2                                                                                                                                                                                           do return wrapper_get_window_size();
get_window_width                               :: inline proc() -> f32                                                                                                                                                                                            do return igGetWindowWidth();
im_alpha_blend_colors                          :: inline proc(col_a: u32, col_b: u32) -> u32                                                                                                                                                                      do return igImAlphaBlendColors(col_a, col_b);
im_bezier_calc                                 :: inline proc(pOut: ^Vec2, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, t: f32)                                                                                                                                        do igImBezierCalc(pOut, p1, p2, p3, p4, t);
im_bezier_closest_point                        :: inline proc(pOut: ^Vec2, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, p: Vec2, num_segments: i32)                                                                                                                    do igImBezierClosestPoint(pOut, p1, p2, p3, p4, p, num_segments);
im_bezier_closest_point_casteljau              :: inline proc(pOut: ^Vec2, p1: Vec2, p2: Vec2, p3: Vec2, p4: Vec2, p: Vec2, tess_tol: f32)                                                                                                                        do igImBezierClosestPointCasteljau(pOut, p1, p2, p3, p4, p, tess_tol);
im_bit_array_clear_bit                         :: inline proc(arr: ^u32, n: i32)                                                                                                                                                                                  do igImBitArrayClearBit(arr, n);
im_bit_array_set_bit                           :: inline proc(arr: ^u32, n: i32)                                                                                                                                                                                  do igImBitArraySetBit(arr, n);
im_bit_array_set_bit_range                     :: inline proc(arr: ^u32, n: i32, n2: i32)                                                                                                                                                                         do igImBitArraySetBitRange(arr, n, n2);
im_bit_array_test_bit                          :: inline proc(arr: ^u32, n: i32) -> bool                                                                                                                                                                          do return igImBitArrayTestBit(arr, n);
im_char_is_blank_a                             :: inline proc(c: i8) -> bool                                                                                                                                                                                      do return igImCharIsBlankA(c);
im_char_is_blank_w                             :: inline proc(c: u32) -> bool                                                                                                                                                                                     do return igImCharIsBlankW(c);
im_clamp                                       :: inline proc(pOut: ^Vec2, v: Vec2, mn: Vec2, mx: Vec2)                                                                                                                                                           do igImClamp(pOut, v, mn, mx);
im_dot                                         :: inline proc(a: Vec2, b: Vec2) -> f32                                                                                                                                                                            do return igImDot(a, b);
im_file_close                                  :: inline proc(file: File_Handle) -> bool                                                                                                                                                                          do return igImFileClose(file);
im_file_get_size                               :: inline proc(file: File_Handle) -> u64                                                                                                                                                                           do return igImFileGetSize(file);
im_file_load_to_memory                         :: inline proc(filename: string, mode: string, out_file_size : ^uint = nil, padding_bytes := i32(0)) -> rawptr                                                                                                     do return swr_igImFileLoadToMemory(filename, mode, out_file_size, padding_bytes);
im_file_open                                   :: inline proc(filename: string, mode: string) -> File_Handle                                                                                                                                                      do return swr_igImFileOpen(filename, mode);
im_file_read                                   :: inline proc(data: rawptr, size: u64, count: u64, file: File_Handle) -> u64                                                                                                                                      do return igImFileRead(data, size, count, file);
im_file_write                                  :: inline proc(data: rawptr, size: u64, count: u64, file: File_Handle) -> u64                                                                                                                                      do return igImFileWrite(data, size, count, file);
im_floor_float                                 :: inline proc(f: f32) -> f32                                                                                                                                                                                      do return igImFloorFloat(f);
im_floor_vec2                                  :: inline proc(pOut: ^Vec2, v: Vec2)                                                                                                                                                                               do igImFloorVec2(pOut, v);
im_font_atlas_build_finish                     :: inline proc(atlas: ^Font_Atlas)                                                                                                                                                                                 do igImFontAtlasBuildFinish(atlas);
im_font_atlas_build_init                       :: inline proc(atlas: ^Font_Atlas)                                                                                                                                                                                 do igImFontAtlasBuildInit(atlas);
im_font_atlas_build_multiply_calc_lookup_table :: inline proc(out_table: [256]u8, in_multiply_factor: f32)                                                                                                                                                        do igImFontAtlasBuildMultiplyCalcLookupTable(out_table, in_multiply_factor);
im_font_atlas_build_multiply_rect_alpha8       :: inline proc(table: [256]u8, pixels: ^u8, x: i32, y: i32, w: i32, h: i32, stride: i32)                                                                                                                           do igImFontAtlasBuildMultiplyRectAlpha8(table, pixels, x, y, w, h, stride);
im_font_atlas_build_pack_custom_rects          :: inline proc(atlas: ^Font_Atlas, stbrp_context_opaque: rawptr)                                                                                                                                                   do igImFontAtlasBuildPackCustomRects(atlas, stbrp_context_opaque);
im_font_atlas_build_setup_font                 :: inline proc(atlas: ^Font_Atlas, font: ^ImFont, font_config: ^Font_Config, ascent: f32, descent: f32)                                                                                                            do igImFontAtlasBuildSetupFont(atlas, font, font_config, ascent, descent);
im_font_atlas_build_with_stb_truetype          :: inline proc(atlas: ^Font_Atlas) -> bool                                                                                                                                                                         do return igImFontAtlasBuildWithStbTruetype(atlas);
im_format_string                               :: inline proc(buf: string, buf_size: uint, fmt_: string, args: ..any) -> i32                                                                                                                                      do return swr_igImFormatString(buf, buf_size, fmt_, args);
im_get_dir_quadrant_from_delta                 :: inline proc(dx: f32, dy: f32) -> Dir                                                                                                                                                                            do return igImGetDirQuadrantFromDelta(dx, dy);
im_hash_data                                   :: inline proc(data: rawptr, data_size: uint, seed := u32(0)) -> u32                                                                                                                                               do return igImHashData(data, data_size, seed);
im_hash_str                                    :: inline proc(data: string, data_size := uint(0), seed := u32(0)) -> u32                                                                                                                                          do return swr_igImHashStr(data, data_size, seed);
im_inv_length                                  :: inline proc(lhs: Vec2, fail_value: f32) -> f32                                                                                                                                                                  do return igImInvLength(lhs, fail_value);
im_is_power_of_two                             :: inline proc(v: i32) -> bool                                                                                                                                                                                     do return igImIsPowerOfTwo(v);

length_sqr :: proc {
	im_length_sqr_vec2,
	im_length_sqr_vec4,
};
im_length_sqr_vec2                             :: inline proc(lhs: Vec2) -> f32                                                                                                                                                                                   do return igImLengthSqrVec2(lhs);
im_length_sqr_vec4                             :: inline proc(lhs: Vec4) -> f32                                                                                                                                                                                   do return igImLengthSqrVec4(lhs);

im_lerp_vec2float                              :: inline proc(pOut: ^Vec2, a: Vec2, b: Vec2, t: f32)                                                                                                                                                              do igImLerpVec2Float(pOut, a, b, t);
im_lerp_vec2vec2                               :: inline proc(pOut: ^Vec2, a: Vec2, b: Vec2, t: Vec2)                                                                                                                                                             do igImLerpVec2Vec2(pOut, a, b, t);
im_lerp_vec4                                   :: inline proc(pOut: ^Vec4, a: Vec4, b: Vec4, t: f32)                                                                                                                                                              do igImLerpVec4(pOut, a, b, t);
im_line_closest_point                          :: inline proc(pOut: ^Vec2, a: Vec2, b: Vec2, p: Vec2)                                                                                                                                                             do igImLineClosestPoint(pOut, a, b, p);
im_linear_sweep                                :: inline proc(current: f32, target: f32, speed: f32) -> f32                                                                                                                                                       do return igImLinearSweep(current, target, speed);
im_max                                         :: inline proc(pOut: ^Vec2, lhs: Vec2, rhs: Vec2)                                                                                                                                                                  do igImMax(pOut, lhs, rhs);
im_min                                         :: inline proc(pOut: ^Vec2, lhs: Vec2, rhs: Vec2)                                                                                                                                                                  do igImMin(pOut, lhs, rhs);
im_mod_positive                                :: inline proc(a: i32, b: i32) -> i32                                                                                                                                                                              do return igImModPositive(a, b);
im_mul                                         :: inline proc(pOut: ^Vec2, lhs: Vec2, rhs: Vec2)                                                                                                                                                                  do igImMul(pOut, lhs, rhs);
im_parse_format_find_end                       :: inline proc(format: string) -> cstring                                                                                                                                                                          do return swr_igImParseFormatFindEnd(format);
im_parse_format_find_start                     :: inline proc(format: string) -> cstring                                                                                                                                                                          do return swr_igImParseFormatFindStart(format);
im_parse_format_precision                      :: inline proc(format: string, default_value: i32) -> i32                                                                                                                                                          do return swr_igImParseFormatPrecision(format, default_value);
im_parse_format_trim_decorations               :: inline proc(format: string, buf: string, buf_size: uint) -> cstring                                                                                                                                             do return swr_igImParseFormatTrimDecorations(format, buf, buf_size);

pow :: proc {
	im_pow_float,
	im_powdouble,
};
im_pow_float                                   :: inline proc(x: f32, y: f32) -> f32                                                                                                                                                                              do return igImPowFloat(x, y);
im_powdouble                                   :: inline proc(x: f64, y: f64) -> f64                                                                                                                                                                              do return igImPowdouble(x, y);

im_rotate                                      :: inline proc(pOut: ^Vec2, v: Vec2, cos_a: f32, sin_a: f32)                                                                                                                                                       do igImRotate(pOut, v, cos_a, sin_a);
im_saturate                                    :: inline proc(f: f32) -> f32                                                                                                                                                                                      do return igImSaturate(f);
im_str_skip_blank                              :: inline proc(str: string) -> cstring                                                                                                                                                                             do return swr_igImStrSkipBlank(str);
im_str_trim_blanks                             :: inline proc(str: string)                                                                                                                                                                                        do swr_igImStrTrimBlanks(str);
im_strbol_w                                    :: inline proc(buf_mid_line: ^Wchar, buf_begin: ^Wchar) -> ^Wchar                                                                                                                                                  do return igImStrbolW(buf_mid_line, buf_begin);
im_strchr_range                                :: inline proc(str_begin: string, str_end: string, c: i8) -> cstring                                                                                                                                               do return swr_igImStrchrRange(str_begin, str_end, c);
im_strdup                                      :: inline proc(str: string) -> cstring                                                                                                                                                                             do return swr_igImStrdup(str);
im_strdupcpy                                   :: inline proc(dst: string, p_dst_size: ^uint, str: string) -> cstring                                                                                                                                             do return swr_igImStrdupcpy(dst, p_dst_size, str);
im_streol_range                                :: inline proc(str: string, str_end: string) -> cstring                                                                                                                                                            do return swr_igImStreolRange(str, str_end);
im_stricmp                                     :: inline proc(str1: string, str2: string) -> i32                                                                                                                                                                  do return swr_igImStricmp(str1, str2);
im_stristr                                     :: inline proc(haystack: string, haystack_end: string, needle: string, needle_end: string) -> cstring                                                                                                              do return swr_igImStristr(haystack, haystack_end, needle, needle_end);
im_strlen_w                                    :: inline proc(str: ^Wchar) -> i32                                                                                                                                                                                 do return igImStrlenW(str);
im_strncpy                                     :: inline proc(dst: string, src: string, count: uint)                                                                                                                                                              do swr_igImStrncpy(dst, src, count);
im_strnicmp                                    :: inline proc(str1: string, str2: string, count: uint) -> i32                                                                                                                                                     do return swr_igImStrnicmp(str1, str2, count);
im_text_char_from_utf8                         :: inline proc(out_char: ^u32, in_text: string, in_text_end: string) -> i32                                                                                                                                        do return swr_igImTextCharFromUtf8(out_char, in_text, in_text_end);
im_text_count_chars_from_utf8                  :: inline proc(in_text: string, in_text_end: string) -> i32                                                                                                                                                        do return swr_igImTextCountCharsFromUtf8(in_text, in_text_end);
im_text_count_utf8bytes_from_char              :: inline proc(in_text: string, in_text_end: string) -> i32                                                                                                                                                        do return swr_igImTextCountUtf8BytesFromChar(in_text, in_text_end);
im_text_count_utf8bytes_from_str               :: inline proc(in_text: ^Wchar, in_text_end: ^Wchar) -> i32                                                                                                                                                        do return igImTextCountUtf8BytesFromStr(in_text, in_text_end);
im_text_str_from_utf8                          :: inline proc(buf: ^Wchar, buf_size: i32, in_text: string, in_text_end: string, in_remaining : ^cstring = nil) -> i32                                                                                             do return swr_igImTextStrFromUtf8(buf, buf_size, in_text, in_text_end, in_remaining);
im_text_str_to_utf8                            :: inline proc(buf: string, buf_size: i32, in_text: ^Wchar, in_text_end: ^Wchar) -> i32                                                                                                                            do return swr_igImTextStrToUtf8(buf, buf_size, in_text, in_text_end);
im_triangle_area                               :: inline proc(a: Vec2, b: Vec2, c: Vec2) -> f32                                                                                                                                                                   do return igImTriangleArea(a, b, c);
im_triangle_barycentric_coords                 :: inline proc(a: Vec2, b: Vec2, c: Vec2, p: Vec2, out_u: ^f32, out_v: ^f32, out_w: ^f32)                                                                                                                          do igImTriangleBarycentricCoords(a, b, c, p, out_u, out_v, out_w);
im_triangle_closest_point                      :: inline proc(pOut: ^Vec2, a: Vec2, b: Vec2, c: Vec2, p: Vec2)                                                                                                                                                    do igImTriangleClosestPoint(pOut, a, b, c, p);
im_triangle_contains_point                     :: inline proc(a: Vec2, b: Vec2, c: Vec2, p: Vec2) -> bool                                                                                                                                                         do return igImTriangleContainsPoint(a, b, c, p);
im_upper_power_of_two                          :: inline proc(v: i32) -> i32                                                                                                                                                                                      do return igImUpperPowerOfTwo(v);
image                                          :: inline proc(user_texture_id: Texture_ID, size: Vec2, uv0 := Vec2(Vec2{0,0}), uv1 := Vec2(Vec2{1,1}), tint_col := Vec4(Vec4{1,1,1,1}), border_col := Vec4(Vec4{0,0,0,0}))                                        do igImage(user_texture_id, size, uv0, uv1, tint_col, border_col);
image_button                                   :: inline proc(user_texture_id: Texture_ID, size: Vec2, uv0 := Vec2(Vec2{0,0}), uv1 := Vec2(Vec2{1,1}), frame_padding := i32(-1), bg_col := Vec4(Vec4{0,0,0,0}), tint_col := Vec4(Vec4{1,1,1,1})) -> bool          do return igImageButton(user_texture_id, size, uv0, uv1, frame_padding, bg_col, tint_col);
indent                                         :: inline proc(indent_w := f32(0.0))                                                                                                                                                                               do igIndent(indent_w);
initialize                                     :: inline proc(ctx: ^Context)                                                                                                                                                                                      do igInitialize(ctx);
input_double                                   :: inline proc(label: string, v: ^f64, step := f64(0.0), step_fast := f64(0.0), format := "%.6f", flags := Input_Text_Flags(0)) -> bool                                                                            do return swr_igInputDouble(label, v, step, step_fast, format, flags);
input_float                                    :: inline proc(label: string, v: ^f32, step := f32(0.0), step_fast := f32(0.0), format := "%.3f", flags := Input_Text_Flags(0)) -> bool                                                                            do return swr_igInputFloat(label, v, step, step_fast, format, flags);
input_float2                                   :: inline proc(label: string, v: [2]f32, format := "%.3f", flags := Input_Text_Flags(0)) -> bool                                                                                                                   do return swr_igInputFloat2(label, v, format, flags);
input_float3                                   :: inline proc(label: string, v: [3]f32, format := "%.3f", flags := Input_Text_Flags(0)) -> bool                                                                                                                   do return swr_igInputFloat3(label, v, format, flags);
input_float4                                   :: inline proc(label: string, v: [4]f32, format := "%.3f", flags := Input_Text_Flags(0)) -> bool                                                                                                                   do return swr_igInputFloat4(label, v, format, flags);
input_int                                      :: inline proc(label: string, v: ^i32, step := i32(1), step_fast := i32(100), flags := Input_Text_Flags(0)) -> bool                                                                                                do return swr_igInputInt(label, v, step, step_fast, flags);
input_int2                                     :: inline proc(label: string, v: [2]i32, flags := Input_Text_Flags(0)) -> bool                                                                                                                                     do return swr_igInputInt2(label, v, flags);
input_int3                                     :: inline proc(label: string, v: [3]i32, flags := Input_Text_Flags(0)) -> bool                                                                                                                                     do return swr_igInputInt3(label, v, flags);
input_int4                                     :: inline proc(label: string, v: [4]i32, flags := Input_Text_Flags(0)) -> bool                                                                                                                                     do return swr_igInputInt4(label, v, flags);
input_scalar                                   :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, p_step : rawptr = nil, p_step_fast : rawptr = nil, format := "", flags := Input_Text_Flags(0)) -> bool                                         do return swr_igInputScalar(label, data_type, p_data, p_step, p_step_fast, format, flags);
input_scalar_n                                 :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, p_step : rawptr = nil, p_step_fast : rawptr = nil, format := "", flags := Input_Text_Flags(0)) -> bool                        do return swr_igInputScalarN(label, data_type, p_data, components, p_step, p_step_fast, format, flags);
input_text                                     :: inline proc(label: string, buf: []u8, flags := Input_Text_Flags(0), callback : Input_Text_Callback = nil, user_data : rawptr = nil) -> bool                                                                     do return wrapper_input_text(label, buf, flags, callback, user_data);
input_text_ex                                  :: inline proc(label: string, hint: string, buf: string, buf_size: i32, size_arg: Vec2, flags: Input_Text_Flags, callback : Input_Text_Callback = nil, user_data : rawptr = nil) -> bool                           do return swr_igInputTextEx(label, hint, buf, buf_size, size_arg, flags, callback, user_data);
input_text_multiline                           :: inline proc(label: string, buf: string, buf_size: uint, size := Vec2(Vec2{0,0}), flags := Input_Text_Flags(0), callback : Input_Text_Callback = nil, user_data : rawptr = nil) -> bool                          do return swr_igInputTextMultiline(label, buf, buf_size, size, flags, callback, user_data);
input_text_with_hint                           :: inline proc(label: string, hint: string, buf: string, buf_size: uint, flags := Input_Text_Flags(0), callback : Input_Text_Callback = nil, user_data : rawptr = nil) -> bool                                     do return swr_igInputTextWithHint(label, hint, buf, buf_size, flags, callback, user_data);
invisible_button                               :: inline proc(str_id: string, size: Vec2) -> bool                                                                                                                                                                 do return swr_igInvisibleButton(str_id, size);
is_active_id_using_key                         :: inline proc(key: Key) -> bool                                                                                                                                                                                   do return igIsActiveIdUsingKey(key);
is_active_id_using_nav_dir                     :: inline proc(dir: Dir) -> bool                                                                                                                                                                                   do return igIsActiveIdUsingNavDir(dir);
is_active_id_using_nav_input                   :: inline proc(input: Nav_Input) -> bool                                                                                                                                                                           do return igIsActiveIdUsingNavInput(input);
is_any_item_active                             :: inline proc() -> bool                                                                                                                                                                                           do return igIsAnyItemActive();
is_any_item_focused                            :: inline proc() -> bool                                                                                                                                                                                           do return igIsAnyItemFocused();
is_any_item_hovered                            :: inline proc() -> bool                                                                                                                                                                                           do return igIsAnyItemHovered();
is_any_mouse_down                              :: inline proc() -> bool                                                                                                                                                                                           do return igIsAnyMouseDown();
is_clipped_ex                                  :: inline proc(bb: Rect, id: ImID, clip_even_when_logged: bool) -> bool                                                                                                                                            do return igIsClippedEx(bb, id, clip_even_when_logged);
is_drag_drop_payload_being_accepted            :: inline proc() -> bool                                                                                                                                                                                           do return igIsDragDropPayloadBeingAccepted();
is_item_activated                              :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemActivated();
is_item_active                                 :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemActive();
is_item_clicked                                :: inline proc(mouse_button := Mouse_Button(0)) -> bool                                                                                                                                                            do return igIsItemClicked(mouse_button);
is_item_deactivated                            :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemDeactivated();
is_item_deactivated_after_edit                 :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemDeactivatedAfterEdit();
is_item_edited                                 :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemEdited();
is_item_focused                                :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemFocused();
is_item_hovered                                :: inline proc(flags := Hovered_Flags(0)) -> bool                                                                                                                                                                  do return igIsItemHovered(flags);
is_item_toggled_open                           :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemToggledOpen();
is_item_toggled_selection                      :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemToggledSelection();
is_item_visible                                :: inline proc() -> bool                                                                                                                                                                                           do return igIsItemVisible();
is_key_down                                    :: inline proc(user_key_index: i32) -> bool                                                                                                                                                                        do return igIsKeyDown(user_key_index);
is_key_pressed                                 :: inline proc(user_key_index: i32, repeat := bool(true)) -> bool                                                                                                                                                  do return igIsKeyPressed(user_key_index, repeat);
is_key_pressed_map                             :: inline proc(key: Key, repeat := bool(true)) -> bool                                                                                                                                                             do return igIsKeyPressedMap(key, repeat);
is_key_released                                :: inline proc(user_key_index: i32) -> bool                                                                                                                                                                        do return igIsKeyReleased(user_key_index);
is_mouse_clicked                               :: inline proc(button: Mouse_Button, repeat := bool(false)) -> bool                                                                                                                                                do return igIsMouseClicked(button, repeat);
is_mouse_double_clicked                        :: inline proc(button: Mouse_Button) -> bool                                                                                                                                                                       do return igIsMouseDoubleClicked(button);
is_mouse_down                                  :: inline proc(button: Mouse_Button) -> bool                                                                                                                                                                       do return igIsMouseDown(button);
is_mouse_drag_past_threshold                   :: inline proc(button: Mouse_Button, lock_threshold := f32(-1.0)) -> bool                                                                                                                                          do return igIsMouseDragPastThreshold(button, lock_threshold);
is_mouse_dragging                              :: inline proc(button: Mouse_Button, lock_threshold := f32(-1.0)) -> bool                                                                                                                                          do return igIsMouseDragging(button, lock_threshold);
is_mouse_hovering_rect                         :: inline proc(r_min: Vec2, r_max: Vec2, clip := bool(true)) -> bool                                                                                                                                               do return igIsMouseHoveringRect(r_min, r_max, clip);
is_mouse_pos_valid                             :: inline proc(mouse_pos : ^Vec2 = nil) -> bool                                                                                                                                                                    do return igIsMousePosValid(mouse_pos);
is_mouse_released                              :: inline proc(button: Mouse_Button) -> bool                                                                                                                                                                       do return igIsMouseReleased(button);
is_nav_input_down                              :: inline proc(n: Nav_Input) -> bool                                                                                                                                                                               do return igIsNavInputDown(n);
is_nav_input_test                              :: inline proc(n: Nav_Input, rm: Input_Read_Mode) -> bool                                                                                                                                                          do return igIsNavInputTest(n, rm);

is_popup_open :: proc {
	is_popup_open_str,
	is_popup_open_id,
};
is_popup_open_str                              :: inline proc(str_id: string) -> bool                                                                                                                                                                             do return swr_igIsPopupOpenStr(str_id);
is_popup_open_id                               :: inline proc(id: ImID) -> bool                                                                                                                                                                                   do return igIsPopupOpenID(id);


is_rect_visible :: proc {
	is_rect_visible_nil,
	is_rect_visible_vec2,
};
is_rect_visible_nil                            :: inline proc(size: Vec2) -> bool                                                                                                                                                                                 do return igIsRectVisibleNil(size);
is_rect_visible_vec2                           :: inline proc(rect_min: Vec2, rect_max: Vec2) -> bool                                                                                                                                                             do return igIsRectVisibleVec2(rect_min, rect_max);

is_window_appearing                            :: inline proc() -> bool                                                                                                                                                                                           do return igIsWindowAppearing();
is_window_child_of                             :: inline proc(window: ^ImWindow, potential_parent: ^ImWindow) -> bool                                                                                                                                             do return igIsWindowChildOf(window, potential_parent);
is_window_collapsed                            :: inline proc() -> bool                                                                                                                                                                                           do return igIsWindowCollapsed();
is_window_focused                              :: inline proc(flags := Focused_Flags(0)) -> bool                                                                                                                                                                  do return igIsWindowFocused(flags);
is_window_hovered                              :: inline proc(flags := Hovered_Flags(0)) -> bool                                                                                                                                                                  do return igIsWindowHovered(flags);
is_window_nav_focusable                        :: inline proc(window: ^ImWindow) -> bool                                                                                                                                                                          do return igIsWindowNavFocusable(window);
item_add                                       :: inline proc(bb: Rect, id: ImID, nav_bb : ^Rect = nil) -> bool                                                                                                                                                   do return igItemAdd(bb, id, nav_bb);
item_hoverable                                 :: inline proc(bb: Rect, id: ImID) -> bool                                                                                                                                                                         do return igItemHoverable(bb, id);

item_size :: proc {
	item_size_vec2,
	item_size_rect,
};
item_size_vec2                                 :: inline proc(size: Vec2, text_baseline_y := f32(-1.0))                                                                                                                                                           do igItemSizeVec2(size, text_baseline_y);
item_size_rect                                 :: inline proc(bb: Rect, text_baseline_y := f32(-1.0))                                                                                                                                                             do igItemSizeRect(bb, text_baseline_y);

keep_alive_id                                  :: inline proc(id: ImID)                                                                                                                                                                                           do igKeepAliveID(id);
label_text                                     :: inline proc(label: string, fmt_: string, args: ..any)                                                                                                                                                           do swr_igLabelText(label, fmt_, args);

list_box :: proc {
	list_box_str_arr,
	list_box_fn_ptr,
};
list_box_str_arr                               :: inline proc(label: string, current_item: ^i32, items: string, items_count: i32, height_in_items := i32(-1)) -> bool                                                                                             do return swr_igListBoxStr_arr(label, current_item, items, items_count, height_in_items);
list_box_fn_ptr                                :: inline proc(label: string, current_item: ^i32, items_getter: Items_Getter_Proc, data: rawptr, items_count: i32, height_in_items := i32(0)) -> bool                                                              do return wrapper_list_box_fn_ptr(label, current_item, items_getter, data, items_count, height_in_items);

list_box_footer                                :: inline proc()                                                                                                                                                                                                   do igListBoxFooter();

list_box_header :: proc {
	list_box_header_vec2,
	list_box_header_int,
};
list_box_header_vec2                           :: inline proc(label: string, size := Vec2(Vec2{0,0})) -> bool                                                                                                                                                     do return swr_igListBoxHeaderVec2(label, size);
list_box_header_int                            :: inline proc(label: string, items_count: i32, height_in_items := i32(-1)) -> bool                                                                                                                                do return swr_igListBoxHeaderInt(label, items_count, height_in_items);

load_ini_settings_from_disk                    :: inline proc(ini_filename: string)                                                                                                                                                                               do swr_igLoadIniSettingsFromDisk(ini_filename);
load_ini_settings_from_memory                  :: inline proc(ini_data: string, ini_size := uint(0))                                                                                                                                                              do swr_igLoadIniSettingsFromMemory(ini_data, ini_size);
log_begin                                      :: inline proc(type: Log_Type, auto_open_depth: i32)                                                                                                                                                               do igLogBegin(type, auto_open_depth);
log_buttons                                    :: inline proc()                                                                                                                                                                                                   do igLogButtons();
log_finish                                     :: inline proc()                                                                                                                                                                                                   do igLogFinish();
log_rendered_text                              :: inline proc(ref_pos: ^Vec2, text: string, text_end := "")                                                                                                                                                       do swr_igLogRenderedText(ref_pos, text, text_end);
log_text                                       :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do swr_igLogText(fmt_, args);
log_to_buffer                                  :: inline proc(auto_open_depth := i32(-1))                                                                                                                                                                         do igLogToBuffer(auto_open_depth);
log_to_clipboard                               :: inline proc(auto_open_depth := i32(-1))                                                                                                                                                                         do igLogToClipboard(auto_open_depth);
log_to_file                                    :: inline proc(auto_open_depth := i32(-1), filename := "")                                                                                                                                                         do swr_igLogToFile(auto_open_depth, filename);
log_to_tty                                     :: inline proc(auto_open_depth := i32(-1))                                                                                                                                                                         do igLogToTTY(auto_open_depth);

mark_ini_settings_dirty :: proc {
	mark_ini_settings_dirty_nil,
	mark_ini_settings_dirty_window_ptr,
};
mark_ini_settings_dirty_nil                    :: inline proc()                                                                                                                                                                                                   do igMarkIniSettingsDirtyNil();
mark_ini_settings_dirty_window_ptr             :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igMarkIniSettingsDirtyWindowPtr(window);

mark_item_edited                               :: inline proc(id: ImID)                                                                                                                                                                                           do igMarkItemEdited(id);
mem_alloc                                      :: inline proc(size: uint) -> rawptr                                                                                                                                                                               do return igMemAlloc(size);
mem_free                                       :: inline proc(ptr: rawptr)                                                                                                                                                                                        do igMemFree(ptr);

menu_item :: proc {
	menu_item_bool,
	menu_item_bool_ptr,
};
menu_item_bool                                 :: inline proc(label: string, shortcut := "", selected := bool(false), enabled := bool(true)) -> bool                                                                                                              do return swr_igMenuItemBool(label, shortcut, selected, enabled);
menu_item_bool_ptr                             :: inline proc(label: string, shortcut: string, p_selected: ^bool, enabled := bool(true)) -> bool                                                                                                                  do return swr_igMenuItemBoolPtr(label, shortcut, p_selected, enabled);

nav_init_window                                :: inline proc(window: ^ImWindow, force_reinit: bool)                                                                                                                                                              do igNavInitWindow(window, force_reinit);
nav_move_request_but_no_result_yet             :: inline proc() -> bool                                                                                                                                                                                           do return igNavMoveRequestButNoResultYet();
nav_move_request_cancel                        :: inline proc()                                                                                                                                                                                                   do igNavMoveRequestCancel();
nav_move_request_forward                       :: inline proc(move_dir: Dir, clip_dir: Dir, bb_rel: Rect, move_flags: Nav_Move_Flags)                                                                                                                             do igNavMoveRequestForward(move_dir, clip_dir, bb_rel, move_flags);
nav_move_request_try_wrapping                  :: inline proc(window: ^ImWindow, move_flags: Nav_Move_Flags)                                                                                                                                                      do igNavMoveRequestTryWrapping(window, move_flags);
new_frame                                      :: inline proc()                                                                                                                                                                                                   do igNewFrame();
new_line                                       :: inline proc()                                                                                                                                                                                                   do igNewLine();
next_column                                    :: inline proc()                                                                                                                                                                                                   do igNextColumn();
open_popup                                     :: inline proc(str_id: string)                                                                                                                                                                                     do swr_igOpenPopup(str_id);
open_popup_ex                                  :: inline proc(id: ImID)                                                                                                                                                                                           do igOpenPopupEx(id);
open_popup_on_item_click                       :: inline proc(str_id := "", mouse_button := Mouse_Button(1)) -> bool                                                                                                                                              do return swr_igOpenPopupOnItemClick(str_id, mouse_button);
plot_ex                                        :: inline proc(plot_type: Plot_Type, label: string, values_getter: Value_Getter_Proc, data: rawptr, values_count: i32, values_offset: i32, overlay_text: string, scale_min: f32, scale_max: f32, frame_size: Vec2) -> i32 do return wrapper_plot_ex(plot_type, label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, frame_size);

plot_histogram :: proc {
	plot_histogram_float_ptr,
	plot_histogram_fn_ptr,
};
plot_histogram_float_ptr                       :: inline proc(label: string, values: ^f32, values_count: i32, values_offset := i32(0), overlay_text := "", scale_min := f32(max(f32)), scale_max := f32(max(f32)), graph_size := Vec2(Vec2{0,0}), stride := i32(size_of(f32))) do swr_igPlotHistogramFloatPtr(label, values, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size, stride);
plot_histogram_fn_ptr                          :: inline proc(label: string, values_getter: Value_Getter_Proc, data: rawptr, values_count: i32, values_offset: i32, overlay_text: string, scale_min: f32, scale_max: f32, graph_size: Vec2)                       do wrapper_plot_histogram_fn_ptr(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);


plot_lines :: proc {
	plot_lines_float_ptr,
	plot_lines_fn_ptr,
};
plot_lines_float_ptr                           :: inline proc(label: string, values: ^f32, values_count: i32, values_offset := i32(0), overlay_text := "", scale_min := f32(max(f32)), scale_max := f32(max(f32)), graph_size := Vec2(Vec2{0,0}), stride := i32(size_of(f32))) do swr_igPlotLinesFloatPtr(label, values, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size, stride);
plot_lines_fn_ptr                              :: inline proc(label: string, values_getter: Value_Getter_Proc, data: rawptr, values_count: i32, values_offset: i32, overlay_text: string, scale_min: f32, scale_max: f32, graph_size: Vec2)                       do wrapper_plot_lines_fn_ptr(label, values_getter, data, values_count, values_offset, overlay_text, scale_min, scale_max, graph_size);

pop_allow_keyboard_focus                       :: inline proc()                                                                                                                                                                                                   do igPopAllowKeyboardFocus();
pop_button_repeat                              :: inline proc()                                                                                                                                                                                                   do igPopButtonRepeat();
pop_clip_rect                                  :: inline proc()                                                                                                                                                                                                   do igPopClipRect();
pop_columns_background                         :: inline proc()                                                                                                                                                                                                   do igPopColumnsBackground();
pop_focus_scope                                :: inline proc()                                                                                                                                                                                                   do igPopFocusScope();
pop_font                                       :: inline proc()                                                                                                                                                                                                   do igPopFont();
pop_id                                         :: inline proc()                                                                                                                                                                                                   do igPopID();
pop_item_flag                                  :: inline proc()                                                                                                                                                                                                   do igPopItemFlag();
pop_item_width                                 :: inline proc()                                                                                                                                                                                                   do igPopItemWidth();
pop_style_color                                :: inline proc(count := i32(1))                                                                                                                                                                                    do igPopStyleColor(count);
pop_style_var                                  :: inline proc(count := i32(1))                                                                                                                                                                                    do igPopStyleVar(count);
pop_text_wrap_pos                              :: inline proc()                                                                                                                                                                                                   do igPopTextWrapPos();
progress_bar                                   :: inline proc(fraction: f32, size_arg := Vec2(Vec2{-1,0}), overlay := "")                                                                                                                                         do swr_igProgressBar(fraction, size_arg, overlay);
push_allow_keyboard_focus                      :: inline proc(allow_keyboard_focus: bool)                                                                                                                                                                         do igPushAllowKeyboardFocus(allow_keyboard_focus);
push_button_repeat                             :: inline proc(repeat: bool)                                                                                                                                                                                       do igPushButtonRepeat(repeat);
push_clip_rect                                 :: inline proc(clip_rect_min: Vec2, clip_rect_max: Vec2, intersect_with_current_clip_rect: bool)                                                                                                                   do igPushClipRect(clip_rect_min, clip_rect_max, intersect_with_current_clip_rect);
push_column_clip_rect                          :: inline proc(column_index: i32)                                                                                                                                                                                  do igPushColumnClipRect(column_index);
push_columns_background                        :: inline proc()                                                                                                                                                                                                   do igPushColumnsBackground();
push_focus_scope                               :: inline proc(id: ImID)                                                                                                                                                                                           do igPushFocusScope(id);
push_font                                      :: inline proc(font: ^ImFont)                                                                                                                                                                                      do igPushFont(font);

push_id :: proc {
	push_id_str,
	push_id_str_str,
	push_id_ptr,
	push_id_int,
};
push_id_str                                    :: inline proc(str_id: string)                                                                                                                                                                                     do swr_igPushIDStr(str_id);
push_id_str_str                                :: inline proc(str_id_begin: string, str_id_end: string)                                                                                                                                                           do swr_igPushIDStrStr(str_id_begin, str_id_end);
push_id_ptr                                    :: inline proc(ptr_id: rawptr)                                                                                                                                                                                     do igPushIDPtr(ptr_id);
push_id_int                                    :: inline proc(int_id: i32)                                                                                                                                                                                        do igPushIDInt(int_id);

push_item_flag                                 :: inline proc(option: Item_Flags, enabled: bool)                                                                                                                                                                  do igPushItemFlag(option, enabled);
push_item_width                                :: inline proc(item_width: f32)                                                                                                                                                                                    do igPushItemWidth(item_width);
push_multi_items_widths                        :: inline proc(components: i32, width_full: f32)                                                                                                                                                                   do igPushMultiItemsWidths(components, width_full);
push_override_id                               :: inline proc(id: ImID)                                                                                                                                                                                           do igPushOverrideID(id);

push_style_color :: proc {
	push_style_color_u32,
	push_style_color_vec4,
};
push_style_color_u32                           :: inline proc(idx: Col, col: u32)                                                                                                                                                                                 do igPushStyleColorU32(idx, col);
push_style_color_vec4                          :: inline proc(idx: Col, col: Vec4)                                                                                                                                                                                do igPushStyleColorVec4(idx, col);


push_style_var :: proc {
	push_style_var_float,
	push_style_var_vec2,
};
push_style_var_float                           :: inline proc(idx: Style_Var, val: f32)                                                                                                                                                                           do igPushStyleVarFloat(idx, val);
push_style_var_vec2                            :: inline proc(idx: Style_Var, val: Vec2)                                                                                                                                                                          do igPushStyleVarVec2(idx, val);

push_text_wrap_pos                             :: inline proc(wrap_local_pos_x := f32(0.0))                                                                                                                                                                       do igPushTextWrapPos(wrap_local_pos_x);

radio_button :: proc {
	radio_button_bool,
	radio_button_int_ptr,
};
radio_button_bool                              :: inline proc(label: string, active: bool) -> bool                                                                                                                                                                do return swr_igRadioButtonBool(label, active);
radio_button_int_ptr                           :: inline proc(label: string, v: ^i32, v_button: i32) -> bool                                                                                                                                                      do return swr_igRadioButtonIntPtr(label, v, v_button);

render                                         :: inline proc()                                                                                                                                                                                                   do igRender();
render_arrow                                   :: inline proc(draw_list: ^Draw_List, pos: Vec2, col: u32, dir: Dir, scale := f32(1.0))                                                                                                                            do igRenderArrow(draw_list, pos, col, dir, scale);
render_arrow_pointing_at                       :: inline proc(draw_list: ^Draw_List, pos: Vec2, half_sz: Vec2, direction: Dir, col: u32)                                                                                                                          do igRenderArrowPointingAt(draw_list, pos, half_sz, direction, col);
render_bullet                                  :: inline proc(draw_list: ^Draw_List, pos: Vec2, col: u32)                                                                                                                                                         do igRenderBullet(draw_list, pos, col);
render_check_mark                              :: inline proc(draw_list: ^Draw_List, pos: Vec2, col: u32, sz: f32)                                                                                                                                                do igRenderCheckMark(draw_list, pos, col, sz);
render_color_rect_with_alpha_checkerboard      :: inline proc(draw_list: ^Draw_List, p_min: Vec2, p_max: Vec2, fill_col: u32, grid_step: f32, grid_off: Vec2, rounding := f32(0.0), rounding_corners_flags: i32)                                                  do igRenderColorRectWithAlphaCheckerboard(draw_list, p_min, p_max, fill_col, grid_step, grid_off, rounding, rounding_corners_flags);
render_frame                                   :: inline proc(p_min: Vec2, p_max: Vec2, fill_col: u32, border := bool(true), rounding := f32(0.0))                                                                                                                do igRenderFrame(p_min, p_max, fill_col, border, rounding);
render_frame_border                            :: inline proc(p_min: Vec2, p_max: Vec2, rounding := f32(0.0))                                                                                                                                                     do igRenderFrameBorder(p_min, p_max, rounding);
render_mouse_cursor                            :: inline proc(draw_list: ^Draw_List, pos: Vec2, scale: f32, mouse_cursor: Mouse_Cursor, col_fill: u32, col_border: u32, col_shadow: u32)                                                                          do igRenderMouseCursor(draw_list, pos, scale, mouse_cursor, col_fill, col_border, col_shadow);
render_nav_highlight                           :: inline proc(bb: Rect, id: ImID, flags := Nav_Highlight_Flags(Nav_Highlight_Flags.TypeDefault))                                                                                                                  do igRenderNavHighlight(bb, id, flags);
render_rect_filled_range_h                     :: inline proc(draw_list: ^Draw_List, rect: Rect, col: u32, x_start_norm: f32, x_end_norm: f32, rounding: f32)                                                                                                     do igRenderRectFilledRangeH(draw_list, rect, col, x_start_norm, x_end_norm, rounding);
render_text                                    :: inline proc(pos: Vec2, text: string, text_end := "", hide_text_after_hash := bool(true))                                                                                                                        do swr_igRenderText(pos, text, text_end, hide_text_after_hash);
render_text_clipped                            :: inline proc(pos_min: Vec2, pos_max: Vec2, text: string, text_end: string, text_size_if_known: ^Vec2, align := Vec2(Vec2{0,0}), clip_rect : ^Rect = nil)                                                         do swr_igRenderTextClipped(pos_min, pos_max, text, text_end, text_size_if_known, align, clip_rect);
render_text_clipped_ex                         :: inline proc(draw_list: ^Draw_List, pos_min: Vec2, pos_max: Vec2, text: string, text_end: string, text_size_if_known: ^Vec2, align := Vec2(Vec2{0,0}), clip_rect : ^Rect = nil)                                  do swr_igRenderTextClippedEx(draw_list, pos_min, pos_max, text, text_end, text_size_if_known, align, clip_rect);
render_text_ellipsis                           :: inline proc(draw_list: ^Draw_List, pos_min: Vec2, pos_max: Vec2, clip_max_x: f32, ellipsis_max_x: f32, text: string, text_end: string, text_size_if_known: ^Vec2)                                               do swr_igRenderTextEllipsis(draw_list, pos_min, pos_max, clip_max_x, ellipsis_max_x, text, text_end, text_size_if_known);
render_text_wrapped                            :: inline proc(pos: Vec2, text: string, text_end: string, wrap_width: f32)                                                                                                                                         do swr_igRenderTextWrapped(pos, text, text_end, wrap_width);
reset_mouse_drag_delta                         :: inline proc(button := Mouse_Button(0))                                                                                                                                                                          do igResetMouseDragDelta(button);
same_line                                      :: inline proc(offset_from_start_x := f32(0.0), spacing := f32(-1.0))                                                                                                                                              do igSameLine(offset_from_start_x, spacing);
save_ini_settings_to_disk                      :: inline proc(ini_filename: string)                                                                                                                                                                               do swr_igSaveIniSettingsToDisk(ini_filename);
save_ini_settings_to_memory                    :: inline proc(out_ini_size : ^uint = nil) -> cstring                                                                                                                                                              do return igSaveIniSettingsToMemory(out_ini_size);
scroll_to_bring_rect_into_view                 :: inline proc(pOut: ^Vec2, window: ^ImWindow, item_rect: Rect)                                                                                                                                                    do igScrollToBringRectIntoView(pOut, window, item_rect);
scrollbar                                      :: inline proc(axis: Axis)                                                                                                                                                                                         do igScrollbar(axis);
scrollbar_ex                                   :: inline proc(bb: Rect, id: ImID, axis: Axis, p_scroll_v: ^f32, avail_v: f32, contents_v: f32, rounding_corners: Draw_Corner_Flags) -> bool                                                                       do return igScrollbarEx(bb, id, axis, p_scroll_v, avail_v, contents_v, rounding_corners);

selectable :: proc {
	selectable_bool,
	selectable_bool_ptr,
};
selectable_bool                                :: inline proc(label: string, selected := bool(false), flags := Selectable_Flags(0), size := Vec2(Vec2{0,0})) -> bool                                                                                              do return swr_igSelectableBool(label, selected, flags, size);
selectable_bool_ptr                            :: inline proc(label: string, p_selected: ^bool, flags := Selectable_Flags(0), size := Vec2(Vec2{0,0})) -> bool                                                                                                    do return swr_igSelectableBoolPtr(label, p_selected, flags, size);

separator                                      :: inline proc()                                                                                                                                                                                                   do igSeparator();
separator_ex                                   :: inline proc(flags: Separator_Flags)                                                                                                                                                                             do igSeparatorEx(flags);
set_active_id                                  :: inline proc(id: ImID, window: ^ImWindow)                                                                                                                                                                        do igSetActiveID(id, window);
set_allocator_functions                        :: inline proc(alloc_func: Alloc_Func, free_func: Free_Func)                                                                                                                                                       do wrapper_set_allocator_functions(alloc_func, free_func);
set_clipboard_text                             :: inline proc(text: string)                                                                                                                                                                                       do swr_igSetClipboardText(text);
set_color_edit_options                         :: inline proc(flags: Color_Edit_Flags)                                                                                                                                                                            do igSetColorEditOptions(flags);
set_column_offset                              :: inline proc(column_index: i32, offset_x: f32)                                                                                                                                                                   do igSetColumnOffset(column_index, offset_x);
set_column_width                               :: inline proc(column_index: i32, width: f32)                                                                                                                                                                      do igSetColumnWidth(column_index, width);
set_current_context                            :: inline proc(ctx: ^Context)                                                                                                                                                                                      do igSetCurrentContext(ctx);
set_current_font                               :: inline proc(font: ^ImFont)                                                                                                                                                                                      do igSetCurrentFont(font);
set_cursor_pos                                 :: inline proc(local_pos: Vec2)                                                                                                                                                                                    do igSetCursorPos(local_pos);
set_cursor_pos_x                               :: inline proc(local_x: f32)                                                                                                                                                                                       do igSetCursorPosX(local_x);
set_cursor_pos_y                               :: inline proc(local_y: f32)                                                                                                                                                                                       do igSetCursorPosY(local_y);
set_cursor_screen_pos                          :: inline proc(pos: Vec2)                                                                                                                                                                                          do igSetCursorScreenPos(pos);
set_drag_drop_payload                          :: inline proc(type: string, data: rawptr, sz: uint, cond := Cond(0)) -> bool                                                                                                                                      do return swr_igSetDragDropPayload(type, data, sz, cond);
set_focus_id                                   :: inline proc(id: ImID, window: ^ImWindow)                                                                                                                                                                        do igSetFocusID(id, window);
set_hovered_id                                 :: inline proc(id: ImID)                                                                                                                                                                                           do igSetHoveredID(id);
set_item_allow_overlap                         :: inline proc()                                                                                                                                                                                                   do igSetItemAllowOverlap();
set_item_default_focus                         :: inline proc()                                                                                                                                                                                                   do igSetItemDefaultFocus();
set_keyboard_focus_here                        :: inline proc(offset := i32(0))                                                                                                                                                                                   do igSetKeyboardFocusHere(offset);
set_mouse_cursor                               :: inline proc(cursor_type: Mouse_Cursor)                                                                                                                                                                          do igSetMouseCursor(cursor_type);
set_nav_id                                     :: inline proc(id: ImID, nav_layer: i32, focus_scope_id: ImID)                                                                                                                                                     do igSetNavID(id, nav_layer, focus_scope_id);
set_nav_id_with_rect_rel                       :: inline proc(id: ImID, nav_layer: i32, focus_scope_id: ImID, rect_rel: Rect)                                                                                                                                     do igSetNavIDWithRectRel(id, nav_layer, focus_scope_id, rect_rel);
set_next_item_open                             :: inline proc(is_open: bool, cond := Cond(0))                                                                                                                                                                     do igSetNextItemOpen(is_open, cond);
set_next_item_width                            :: inline proc(item_width: f32)                                                                                                                                                                                    do igSetNextItemWidth(item_width);
set_next_window_bg_alpha                       :: inline proc(alpha: f32)                                                                                                                                                                                         do igSetNextWindowBgAlpha(alpha);
set_next_window_collapsed                      :: inline proc(collapsed: bool, cond := Cond(0))                                                                                                                                                                   do igSetNextWindowCollapsed(collapsed, cond);
set_next_window_content_size                   :: inline proc(size: Vec2)                                                                                                                                                                                         do igSetNextWindowContentSize(size);
set_next_window_focus                          :: inline proc()                                                                                                                                                                                                   do igSetNextWindowFocus();
set_next_window_pos                            :: inline proc(pos: Vec2, cond := Cond(0), pivot := Vec2(Vec2{0,0}))                                                                                                                                               do igSetNextWindowPos(pos, cond, pivot);
set_next_window_size                           :: inline proc(size: Vec2, cond := Cond(0))                                                                                                                                                                        do igSetNextWindowSize(size, cond);
set_next_window_size_constraints               :: inline proc(size_min: Vec2, size_max: Vec2, custom_callback : Size_Callback = nil, custom_callback_data : rawptr = nil)                                                                                         do igSetNextWindowSizeConstraints(size_min, size_max, custom_callback, custom_callback_data);

set_scroll_from_pos_x :: proc {
	set_scroll_from_pos_x_float,
	set_scroll_from_pos_x_window_ptr,
};
set_scroll_from_pos_x_float                    :: inline proc(local_x: f32, center_x_ratio := f32(0.5))                                                                                                                                                           do igSetScrollFromPosXFloat(local_x, center_x_ratio);
set_scroll_from_pos_x_window_ptr               :: inline proc(window: ^ImWindow, local_x: f32, center_x_ratio := f32(0.5))                                                                                                                                        do igSetScrollFromPosXWindowPtr(window, local_x, center_x_ratio);


set_scroll_from_pos_y :: proc {
	set_scroll_from_pos_y_float,
	set_scroll_from_pos_y_window_ptr,
};
set_scroll_from_pos_y_float                    :: inline proc(local_y: f32, center_y_ratio := f32(0.5))                                                                                                                                                           do igSetScrollFromPosYFloat(local_y, center_y_ratio);
set_scroll_from_pos_y_window_ptr               :: inline proc(window: ^ImWindow, local_y: f32, center_y_ratio := f32(0.5))                                                                                                                                        do igSetScrollFromPosYWindowPtr(window, local_y, center_y_ratio);

set_scroll_here_x                              :: inline proc(center_x_ratio := f32(0.5))                                                                                                                                                                         do igSetScrollHereX(center_x_ratio);
set_scroll_here_y                              :: inline proc(center_y_ratio := f32(0.5))                                                                                                                                                                         do igSetScrollHereY(center_y_ratio);

set_scroll_x :: proc {
	set_scroll_x_float,
	set_scroll_x_window_ptr,
};
set_scroll_x_float                             :: inline proc(scroll_x: f32)                                                                                                                                                                                      do igSetScrollXFloat(scroll_x);
set_scroll_x_window_ptr                        :: inline proc(window: ^ImWindow, new_scroll_x: f32)                                                                                                                                                               do igSetScrollXWindowPtr(window, new_scroll_x);


set_scroll_y :: proc {
	set_scroll_y_float,
	set_scroll_y_window_ptr,
};
set_scroll_y_float                             :: inline proc(scroll_y: f32)                                                                                                                                                                                      do igSetScrollYFloat(scroll_y);
set_scroll_y_window_ptr                        :: inline proc(window: ^ImWindow, new_scroll_y: f32)                                                                                                                                                               do igSetScrollYWindowPtr(window, new_scroll_y);

set_state_storage                              :: inline proc(storage: ^Storage)                                                                                                                                                                                  do igSetStateStorage(storage);
set_tab_item_closed                            :: inline proc(tab_or_docked_window_label: string)                                                                                                                                                                 do swr_igSetTabItemClosed(tab_or_docked_window_label);
set_tooltip                                    :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do swr_igSetTooltip(fmt_, args);

set_window_collapsed :: proc {
	set_window_collapsed_bool,
	set_window_collapsed_str,
	set_window_collapsed_window_ptr,
};
set_window_collapsed_bool                      :: inline proc(collapsed: bool, cond := Cond(0))                                                                                                                                                                   do igSetWindowCollapsedBool(collapsed, cond);
set_window_collapsed_str                       :: inline proc(name: string, collapsed: bool, cond := Cond(0))                                                                                                                                                     do swr_igSetWindowCollapsedStr(name, collapsed, cond);
set_window_collapsed_window_ptr                :: inline proc(window: ^ImWindow, collapsed: bool, cond := Cond(0))                                                                                                                                                do igSetWindowCollapsedWindowPtr(window, collapsed, cond);


set_window_focus :: proc {
	set_window_focus_nil,
	set_window_focus_str,
};
set_window_focus_nil                           :: inline proc()                                                                                                                                                                                                   do igSetWindowFocusNil();
set_window_focus_str                           :: inline proc(name: string)                                                                                                                                                                                       do swr_igSetWindowFocusStr(name);

set_window_font_scale                          :: inline proc(scale: f32)                                                                                                                                                                                         do igSetWindowFontScale(scale);

set_window_pos :: proc {
	set_window_pos_vec2,
	set_window_pos_str,
	set_window_pos_window_ptr,
};
set_window_pos_vec2                            :: inline proc(pos: Vec2, cond := Cond(0))                                                                                                                                                                         do igSetWindowPosVec2(pos, cond);
set_window_pos_str                             :: inline proc(name: string, pos: Vec2, cond := Cond(0))                                                                                                                                                           do swr_igSetWindowPosStr(name, pos, cond);
set_window_pos_window_ptr                      :: inline proc(window: ^ImWindow, pos: Vec2, cond := Cond(0))                                                                                                                                                      do igSetWindowPosWindowPtr(window, pos, cond);


set_window_size :: proc {
	set_window_size_vec2,
	set_window_size_str,
	set_window_size_window_ptr,
};
set_window_size_vec2                           :: inline proc(size: Vec2, cond := Cond(0))                                                                                                                                                                        do igSetWindowSizeVec2(size, cond);
set_window_size_str                            :: inline proc(name: string, size: Vec2, cond := Cond(0))                                                                                                                                                          do swr_igSetWindowSizeStr(name, size, cond);
set_window_size_window_ptr                     :: inline proc(window: ^ImWindow, size: Vec2, cond := Cond(0))                                                                                                                                                     do igSetWindowSizeWindowPtr(window, size, cond);

shade_verts_linear_color_gradient_keep_alpha   :: inline proc(draw_list: ^Draw_List, vert_start_idx: i32, vert_end_idx: i32, gradient_p0: Vec2, gradient_p1: Vec2, col0: u32, col1: u32)                                                                          do igShadeVertsLinearColorGradientKeepAlpha(draw_list, vert_start_idx, vert_end_idx, gradient_p0, gradient_p1, col0, col1);
shade_verts_linear_uv                          :: inline proc(draw_list: ^Draw_List, vert_start_idx: i32, vert_end_idx: i32, a: Vec2, b: Vec2, uv_a: Vec2, uv_b: Vec2, clamp: bool)                                                                               do igShadeVertsLinearUV(draw_list, vert_start_idx, vert_end_idx, a, b, uv_a, uv_b, clamp);
show_about_window                              :: inline proc(p_open : ^bool = nil)                                                                                                                                                                               do igShowAboutWindow(p_open);
show_demo_window                               :: inline proc(p_open : ^bool = nil)                                                                                                                                                                               do igShowDemoWindow(p_open);
show_font_selector                             :: inline proc(label: string)                                                                                                                                                                                      do swr_igShowFontSelector(label);
show_metrics_window                            :: inline proc(p_open : ^bool = nil)                                                                                                                                                                               do igShowMetricsWindow(p_open);
show_style_editor                              :: inline proc(ref : ^Style = nil)                                                                                                                                                                                 do igShowStyleEditor(ref);
show_style_selector                            :: inline proc(label: string) -> bool                                                                                                                                                                              do return swr_igShowStyleSelector(label);
show_user_guide                                :: inline proc()                                                                                                                                                                                                   do igShowUserGuide();
shrink_widths                                  :: inline proc(items: ^Shrink_Width_Item, count: i32, width_excess: f32)                                                                                                                                           do igShrinkWidths(items, count, width_excess);
shutdown                                       :: inline proc(ctx: ^Context)                                                                                                                                                                                      do igShutdown(ctx);
slider_angle                                   :: inline proc(label: string, v_rad: ^f32, v_degrees_min := f32(-360.0), v_degrees_max := f32(+360.0), format := "%.0f deg") -> bool                                                                               do return swr_igSliderAngle(label, v_rad, v_degrees_min, v_degrees_max, format);
slider_behavior                                :: inline proc(bb: Rect, id: ImID, data_type: Data_Type, p_v: rawptr, p_min: rawptr, p_max: rawptr, format: string, power: f32, flags: Slider_Flags, out_grab_bb: ^Rect) -> bool                                   do return swr_igSliderBehavior(bb, id, data_type, p_v, p_min, p_max, format, power, flags, out_grab_bb);
slider_float                                   :: inline proc(label: string, v: ^f32, v_min: f32, v_max: f32, format := "%.3f", power := f32(1.0)) -> bool                                                                                                        do return swr_igSliderFloat(label, v, v_min, v_max, format, power);
slider_float2                                  :: inline proc(label: string, v: [2]f32, v_min: f32, v_max: f32, format := "%.3f", power := f32(1.0)) -> bool                                                                                                      do return swr_igSliderFloat2(label, v, v_min, v_max, format, power);
slider_float3                                  :: inline proc(label: string, v: [3]f32, v_min: f32, v_max: f32, format := "%.3f", power := f32(1.0)) -> bool                                                                                                      do return swr_igSliderFloat3(label, v, v_min, v_max, format, power);
slider_float4                                  :: inline proc(label: string, v: [4]f32, v_min: f32, v_max: f32, format := "%.3f", power := f32(1.0)) -> bool                                                                                                      do return swr_igSliderFloat4(label, v, v_min, v_max, format, power);
slider_int                                     :: inline proc(label: string, v: ^i32, v_min: i32, v_max: i32, format := "%d") -> bool                                                                                                                             do return swr_igSliderInt(label, v, v_min, v_max, format);
slider_int2                                    :: inline proc(label: string, v: [2]i32, v_min: i32, v_max: i32, format := "%d") -> bool                                                                                                                           do return swr_igSliderInt2(label, v, v_min, v_max, format);
slider_int3                                    :: inline proc(label: string, v: [3]i32, v_min: i32, v_max: i32, format := "%d") -> bool                                                                                                                           do return swr_igSliderInt3(label, v, v_min, v_max, format);
slider_int4                                    :: inline proc(label: string, v: [4]i32, v_min: i32, v_max: i32, format := "%d") -> bool                                                                                                                           do return swr_igSliderInt4(label, v, v_min, v_max, format);
slider_scalar                                  :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, p_min: rawptr, p_max: rawptr, format := "", power := f32(1.0)) -> bool                                                                         do return swr_igSliderScalar(label, data_type, p_data, p_min, p_max, format, power);
slider_scalar_n                                :: inline proc(label: string, data_type: Data_Type, p_data: rawptr, components: i32, p_min: rawptr, p_max: rawptr, format := "", power := f32(1.0)) -> bool                                                        do return swr_igSliderScalarN(label, data_type, p_data, components, p_min, p_max, format, power);
small_button                                   :: inline proc(label: string) -> bool                                                                                                                                                                              do return swr_igSmallButton(label);
spacing                                        :: inline proc()                                                                                                                                                                                                   do igSpacing();
splitter_behavior                              :: inline proc(bb: Rect, id: ImID, axis: Axis, size1: ^f32, size2: ^f32, min_size1: f32, min_size2: f32, hover_extend := f32(0.0), hover_visibility_delay := f32(0.0)) -> bool                                     do return igSplitterBehavior(bb, id, axis, size1, size2, min_size1, min_size2, hover_extend, hover_visibility_delay);
start_mouse_moving_window                      :: inline proc(window: ^ImWindow)                                                                                                                                                                                  do igStartMouseMovingWindow(window);
style_colors_classic                           :: inline proc(dst : ^Style = nil)                                                                                                                                                                                 do igStyleColorsClassic(dst);
style_colors_dark                              :: inline proc(dst : ^Style = nil)                                                                                                                                                                                 do igStyleColorsDark(dst);
style_colors_light                             :: inline proc(dst : ^Style = nil)                                                                                                                                                                                 do igStyleColorsLight(dst);
tab_bar_close_tab                              :: inline proc(tab_bar: ^Tab_Bar, tab: ^Tab_Item)                                                                                                                                                                  do igTabBarCloseTab(tab_bar, tab);
tab_bar_find_tab_by_id                         :: inline proc(tab_bar: ^Tab_Bar, tab_id: ImID) -> ^Tab_Item                                                                                                                                                       do return igTabBarFindTabByID(tab_bar, tab_id);
tab_bar_queue_change_tab_order                 :: inline proc(tab_bar: ^Tab_Bar, tab: ^Tab_Item, dir: i32)                                                                                                                                                        do igTabBarQueueChangeTabOrder(tab_bar, tab, dir);
tab_bar_remove_tab                             :: inline proc(tab_bar: ^Tab_Bar, tab_id: ImID)                                                                                                                                                                    do igTabBarRemoveTab(tab_bar, tab_id);
tab_item_background                            :: inline proc(draw_list: ^Draw_List, bb: Rect, flags: Tab_Item_Flags, col: u32)                                                                                                                                   do igTabItemBackground(draw_list, bb, flags, col);
tab_item_calc_size                             :: inline proc(pOut: ^Vec2, label: string, has_close_button: bool)                                                                                                                                                 do swr_igTabItemCalcSize(pOut, label, has_close_button);
tab_item_ex                                    :: inline proc(tab_bar: ^Tab_Bar, label: string, p_open: ^bool, flags: Tab_Item_Flags) -> bool                                                                                                                     do return swr_igTabItemEx(tab_bar, label, p_open, flags);
tab_item_label_and_close_button                :: inline proc(draw_list: ^Draw_List, bb: Rect, flags: Tab_Item_Flags, frame_padding: Vec2, label: string, tab_id: ImID, close_button_id: ImID) -> bool                                                            do return swr_igTabItemLabelAndCloseButton(draw_list, bb, flags, frame_padding, label, tab_id, close_button_id);
temp_input_is_active                           :: inline proc(id: ImID) -> bool                                                                                                                                                                                   do return igTempInputIsActive(id);
temp_input_scalar                              :: inline proc(bb: Rect, id: ImID, label: string, data_type: Data_Type, p_data: rawptr, format: string) -> bool                                                                                                    do return swr_igTempInputScalar(bb, id, label, data_type, p_data, format);
temp_input_text                                :: inline proc(bb: Rect, id: ImID, label: string, buf: string, buf_size: i32, flags: Input_Text_Flags) -> bool                                                                                                     do return swr_igTempInputText(bb, id, label, buf, buf_size, flags);
text                                           :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do wrapper_text(fmt_, ..args);
text_colored                                   :: inline proc(col: Vec4, fmt_: string, args: ..any)                                                                                                                                                               do wrapper_text_colored(col, fmt_, ..args);
text_disabled                                  :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do wrapper_text_disabled(fmt_, ..args);
text_ex                                        :: inline proc(text: string, flags := Text_Flags(0))                                                                                                                                                               do wrapper_text_ex(text, flags);
text_unformatted                               :: inline proc(text: string)                                                                                                                                                                                       do wrapper_unformatted_text(text);
text_wrapped                                   :: inline proc(fmt_: string, args: ..any)                                                                                                                                                                          do wrapper_text_wrapped(fmt_, ..args);

tree_node :: proc {
	tree_node_str,
	tree_node_str_str,
	tree_node_ptr,
};
tree_node_str                                  :: inline proc(label: string) -> bool                                                                                                                                                                              do return swr_igTreeNodeStr(label);
tree_node_str_str                              :: inline proc(str_id: string, fmt_: string, args: ..any) -> bool                                                                                                                                                  do return swr_igTreeNodeStrStr(str_id, fmt_, args);
tree_node_ptr                                  :: inline proc(ptr_id: rawptr, fmt_: string, args: ..any) -> bool                                                                                                                                                  do return swr_igTreeNodePtr(ptr_id, fmt_, args);

tree_node_behavior                             :: inline proc(id: ImID, flags: Tree_Node_Flags, label: string, label_end := "") -> bool                                                                                                                           do return swr_igTreeNodeBehavior(id, flags, label, label_end);
tree_node_behavior_is_open                     :: inline proc(id: ImID, flags := Tree_Node_Flags(0)) -> bool                                                                                                                                                      do return igTreeNodeBehaviorIsOpen(id, flags);

tree_node_ex :: proc {
	tree_node_ex_str,
	tree_node_ex_str_str,
	tree_node_ex_ptr,
};
tree_node_ex_str                               :: inline proc(label: string, flags := Tree_Node_Flags(0)) -> bool                                                                                                                                                 do return swr_igTreeNodeExStr(label, flags);
tree_node_ex_str_str                           :: inline proc(str_id: string, flags: Tree_Node_Flags, fmt_: string, args: ..any) -> bool                                                                                                                          do return swr_igTreeNodeExStrStr(str_id, flags, fmt_, args);
tree_node_ex_ptr                               :: inline proc(ptr_id: rawptr, flags: Tree_Node_Flags, fmt_: string, args: ..any) -> bool                                                                                                                          do return swr_igTreeNodeExPtr(ptr_id, flags, fmt_, args);

tree_pop                                       :: inline proc()                                                                                                                                                                                                   do igTreePop();

tree_push :: proc {
	tree_push_str,
	tree_push_ptr,
};
tree_push_str                                  :: inline proc(str_id: string)                                                                                                                                                                                     do swr_igTreePushStr(str_id);
tree_push_ptr                                  :: inline proc(ptr_id : rawptr = nil)                                                                                                                                                                              do igTreePushPtr(ptr_id);

tree_push_override_id                          :: inline proc(id: ImID)                                                                                                                                                                                           do igTreePushOverrideID(id);
unindent                                       :: inline proc(indent_w := f32(0.0))                                                                                                                                                                               do igUnindent(indent_w);
update_hovered_window_and_capture_flags        :: inline proc()                                                                                                                                                                                                   do igUpdateHoveredWindowAndCaptureFlags();
update_mouse_moving_window_end_frame           :: inline proc()                                                                                                                                                                                                   do igUpdateMouseMovingWindowEndFrame();
update_mouse_moving_window_new_frame           :: inline proc()                                                                                                                                                                                                   do igUpdateMouseMovingWindowNewFrame();
update_window_parent_and_root_links            :: inline proc(window: ^ImWindow, flags: Window_Flags, parent_window: ^ImWindow)                                                                                                                                   do igUpdateWindowParentAndRootLinks(window, flags, parent_window);
v_slider_float                                 :: inline proc(label: string, size: Vec2, v: ^f32, v_min: f32, v_max: f32, format := "%.3f", power := f32(1.0)) -> bool                                                                                            do return swr_igVSliderFloat(label, size, v, v_min, v_max, format, power);
v_slider_int                                   :: inline proc(label: string, size: Vec2, v: ^i32, v_min: i32, v_max: i32, format := "%d") -> bool                                                                                                                 do return swr_igVSliderInt(label, size, v, v_min, v_max, format);
v_slider_scalar                                :: inline proc(label: string, size: Vec2, data_type: Data_Type, p_data: rawptr, p_min: rawptr, p_max: rawptr, format := "", power := f32(1.0)) -> bool                                                             do return swr_igVSliderScalar(label, size, data_type, p_data, p_min, p_max, format, power);

value :: proc {
	value_bool,
	value_int,
	value_uint,
	value_float,
};
value_bool                                     :: inline proc(prefix: string, b: bool)                                                                                                                                                                            do swr_igValueBool(prefix, b);
value_int                                      :: inline proc(prefix: string, v: i32)                                                                                                                                                                             do swr_igValueInt(prefix, v);
value_uint                                     :: inline proc(prefix: string, v: u32)                                                                                                                                                                             do swr_igValueUint(prefix, v);
value_float                                    :: inline proc(prefix: string, v: f32, float_format := "")                                                                                                                                                         do swr_igValueFloat(prefix, v, float_format);


